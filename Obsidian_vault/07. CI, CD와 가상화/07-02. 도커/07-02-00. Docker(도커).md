# 도커 설치
- https://docs.docker.com/engine/install/ubuntu/
	```
	# Add Docker's official GPG key:
	sudo apt-get update
	sudo apt-get install ca-certificates curl
	sudo install -m 0755 -d /etc/apt/keyrings
	sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
	sudo chmod a+r /etc/apt/keyrings/docker.asc
	
	# Add the repository to Apt sources:
	echo \
	  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
	  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
	  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
	sudo apt-get update
	```
	
	```
	# 설치확인
	systemctl status docker
	```

- # 도커의 기본 개념
	- ## 도커(docker)
		- 컨테이너(container)라고 부르는 패키지 형태로 소프트웨어를 배ㅎ포하는 OS-level 가상화 기술을 사용 한 PaaS(platform as a service)제품이다.
		- 컨테이너 관리하고 소프트웨어를 도커 엔진(Docker Engine)이라고 부른다.
	- ## 가상화 (virtualization)
		- 물리적인 자원을 논리적인 자원으로 변환해서 사용하는 것
		- ### 종류
		1. 호스트 가상화(Host virtualization)
		2. 하이퍼 바이저 가상화 (Hypervisor virtualization)
			2-1) 전 가상화(Full virtualization) : 하드웨어를 사아화
			2-2) 반 가상화(Para-virtualization) : 하드웨어를 가상화하진 않음
		3. OS level 가상화(OS level virtualization), 컨테이너 가상화(container virtualization
		
			bins(바이너리)/libs(라이브러리)
			컨테이너 는 OS가 아니다!!
- # 도커의 구조
	- ## 도커엔진(docker engine) 
		- 애플리케이션을 컨테이너화 하기 위한 오픈 소스 컨테이너화 기술(open source containerization technology)
		- 도커 엔진은 다음과 같은 클라이언트-서버 역할을 한다.
			- dockerd 와 같은 데몬 프로세스가 실행되는 서버
			- 도커 데몬과 의사소통하기 위한 API 역할
			- 커멘드 라인 인터페이스 (CLI) 클라이언트 docker
		![](https://i.imgur.com/bOYE8Tw.png)
	- ## 도커 데몬(docker daemon, dockerd)
		- 호스트(host)에서 메모리에 상주하여 백그라운드에 컨테이너를 관리하는 프로세스
		- 클라이언트의 요청을 기다리고 있다가 요청이 발생하면 이에 적절히 대응함 
		- 즉, 메모리에 상주하면서 특정 요청이 오면 즉시 대응할 수 있도록 대기 중인 프로세스를 의미
		- 도커 사용자는 도커 데몬과 통신함
	- ## 도커 이미지(docker image)
		- 도커 이미지는 도커 컨테이너를 실행하기 위해 필요한 모든 것을 모아놓은 패키지
		-  기본적으로 코드, 라이브러리 및 컨테이너가 어떻게 인스턴스화 되어야하는지에 대한 내용 포함
		- 해당 소프트웨어 구성물이 어떻게 실행되어야 하는지도 포함
		- 도커 이미지가 가상머신 환경의 **스냅샷**이라고도 볼수 있음
		- 즉, 실행 중인 도커 컨테이너의 특정 시점을 나타낸다라고 할수 있음
	- ## 도커 컨테이너(docker container)
		- 실행 가능한 도커 이미지의 인스턴스
		- 하나의 프로세스라고도 볼수 있음(다른 프로세스들과 완전히 분리된)
		- 도커 컨테이너는 가상화된 런타임 환경
			- 런타임(runtime): 프로그램이 실행되고 있는 동안의 동작을 의미
	- ## 도커 레지스트리(docker registry)
		- 도커 이미지 저장소, 도커 이미지가 보관되는 곳
		- 기본적으로 도커 허브(docker hub)에 있는 이미지를 찾도록 설정되어 있음
	![400](https://i.imgur.com/R0pw52A.png) 
	- ## containerd vs runc 차이점
		- runc 는 OCI(Open Container Image) 인터페이스를 실행하기 위한 lowest level 구성요소
			- OCI (Open Container Image)
				- 컨테이너 표준 사양을 책정하기 위해 만들어진 단체
				- 처음에는 도커가 컨테이너의 표준이었는데 다양한 컨테이너 런타임이 생김
					-> 업계 표준이 필요함
				- 도커, CoreOS, 구글, IBM, 레드햇, AWS, VMware, HP, EMC, Pivotal, 마이크로소프트, 리눅스 파운데이션 등 참가
		- runc는 containerd의 구성 요소로써 커널 레벨에서 컨테이너를 실행한다.
		- containerd는 컨테이너 라이프 사이클을 완벅하게 관리하는 컨테이너 런타임이다.
			- 컨테이너 라이프 사이클: 이미지 전송/ 저장부터 컨테이너 실행 및 네트워크 관리 등을 포함
		- containerd는 네트워크, 이미지 전송/저장 등과 같이 runc보다 더 포괄적으로 관여하는 부분이 많음
			- runc는 container를 실행하는 그 자체의 기능에만 집중함.
			- containerd는 runc가 잘 실행할수 있도록 도와준다고 보면됨.
		- 널게 보면 도커 엔진은 유저의 커맨드 입력받고 도커 레지스트리에서 이미지를 다운로드 받는 등의 일을 함.
	- ## hello-world의 의미
		```
		이미지 build
		컨테이너 pull
		허브 run
		
		docker ps, docker run <- 옜날 명령어 (image인지 container 인지 혼동)
		docker image ls, docker container ls
		docker container run
		```
		- 도커 hello-world
			```
			$ docker container run hello-world
			```
		- 도커 이미지 확인
			```
			$ docker image ls
			```
		- 도커 컨테이너 확인
			```
			- 작동중인 컨테이너 : $ docker container ls
			- 모든 컨테이너 : $ docker container ls -a
			```
		- 도커 containerd 확인
			```
			$ sudo -i
			cd /run/docker
			ll
			아무것도 없음을 확인
			cd ..
			cd runtime-runc/
			moby : 초기 도커 프로젝트 이름
			```
	- ## docker container run
		```
		우분투 이미지를 컨테이너로 실행
		docker image ls
		ubuntu -> image id 
		docker container run (image id)
		docker container ls -a
		```
		- 이미지는 컨테이너로 변환되어 하나의 인스턴스가 됨
		- 실행의 컨테이너는 IP 주소를 가지는 하나의 독립된 서버처럼 동작함
		- 각 컨테이너는 고유의 IP 주소와 포트 번호를 가지고 있음
		- 컨테이너는 실행할 때마다 새로운 IP 주소를 가지게 됨(이전 이력과 관계없음)
- # 도커 기본 명령어
	- ## 컨테이너 네트워크
		- ### (터미널1) 컨테이너 내부에서 bash shell 실행
			```
			$ docker container run -it ubuntu /bin/bash
			```
			- i (interactive) 옵션 : 키보드 입력을 컨테이너 표준 입력에 연결해 컨테이너 shell에 보냄
			- t (tty) 옵션 : 터미널을 통해 대화형 조작이 가능하게 함
			- 운영체제 처럼 보이지만 아니다
		- ### (터미널2)새로운 터미널을 열고 컨테이너 ls 확인
			```
			$ docker container ls
			```
		- ### 터미널2에서 터미널1에 실행중인 컨테이너 접속
			```
			$ docker exec -it {컨테이너ID} bash
			```
		- ### 실행중인 컨테이너 종료
			```
			docker container stop {컨테이너ID}
			```
	- ## 도커 이미지 변경후 저장
		```
		(터미널1)docker container run -it ubuntu /bin/bash
		(터미널1)ifconfig
			apt-get update&&apt-get install net-tools
		(터미널2)docker container ls
		(터미널2)docker container commit {컨테이너ID} my-ubuntu:0.1
		(터미널2)docker image ls
		
		이미지 삭제
		(호스트)docker image ls
			-> 삭제할 IMAGE ID 확인 
		(호스트)docker image rm {이미지ID}
		```
	- ## 호스트 <-> 컨테이너 간 파일 전송
		```
		호스트 -> 컨테이너 파일 전송
		호스트 터미널에서 실행
		(터미널1) mkdir work&& cd $_&&vim while_loop.py 
		docker container cp ./while_loop.py 75fe5a9aace8:/home
		
		컨테이너 -> 호스트 파일 전송
		호스트 터미널에서 실행
		(터미널1)docker container cp 75fe5a9aace8:/home/while_loop.py ./
		```
- # 부록
	- pyenv 설치 & 가상환경 만들기 & 라이브러리 설치
	```
	sudo apt-get update; sudo apt-get install make build-essential libssl-dev zlib1g-dev \
	
	libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \
	
	libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev
	
	curl https://pyenv.run | bash
	복사
	export PYENV_ROOT="$HOME/.pyenv"
	[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
	eval "$(pyenv init -)"
	
	eval "$(pyenv virtualenv-init -)"
	
	vim .bashrc
	제일 하단에 붙여넣기
	export PYENV_ROOT="$HOME/.pyenv"
	[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
	eval "$(pyenv init -)"
	eval "$(pyenv virtualenv-init -)"
	
	쉘 재실행
	exec $SHELL
	
	설치
	pyenv install 3.11.9
	
	가상환경 생성
	pyenv virtualenv 3.11.9 py3_11_9
	```