## 운영체제
- 하드웨어 위에 설치되어 하드웨어 계층과 다른 소프트웨어 계층을 연결하는 소프트웨어 계층
- 컴퓨터 시스템의 자원을 관리하고, 사용자가 컴퓨터를 사용할 수 있는 환경 제공
- 사용자와 컴퓨터간 인터페이스 제공
- 대표적 OS: Windows, MacOS, Linux, Unix 등


|  운영체제의 위치  |
| :--------: |
| **응용프로그램** |
|  **유틸리티**  |
|  **운영체제**  |
|  **하드웨어**  |

### 운영체제의 목적
- 처리 능력(throughput) 향상
  - OS는 자원 관리를 통해 일정 시간 내에 시스템이 처리하는 일의 양을 향상시킴
- 반환 시간(turnaround time) 단축
  - OS는 사용자가 시스템에 요청한 작업을 완료할 때까지 소요되는 시간을 단축시킴
- 사용 가능도(availability) 향상
  - 사용 가능도: 시스템 자원을 얼마나 빨리 제공할 수 있는지를 나타내는 정도
  - OS는 사용자가 컴퓨터를 사용해야 할 때 자원을 즉시 사용할 수 있게 함
- 신뢰도(reliability) 향상
  - 신뢰도: 시스템이 주어진 문제를 정확하게 푸는 정도
  - OS는 입력 값에 대한 정확한 결과 값을 줄 수 있도록 신뢰도를 향상해야 함

#### OS 평가 기준
- 처리 능력
- 반환 시간
- 사용 가능도
- 신뢰도

### CPU와 메모리 구조
- CPU
  - 컴퓨터에서 프로그램을 실행하는 데 필요한 연산을 처리하고 수행
  - `프로세서`라고도 함
- 메모리
  - 데이터를 저장하기 위한 기억장치
  - 휘발성 메모리인 `주 기억장치`: `RAM`
  - 비휘발성 메모리인 `보조 기억장치`: `SSD`, `HDD` 등


| **메모리의 계층 구조** |
| :------------: |
|    **레지스터**    |
|     **캐시**     |
|    **RAM**     |
|  **HDD, SSD**  |

- 프로그램 실행: OS가 디스크에 있는 프로그램을 메모리로 `로드(Load)` 후 CPU가 처리
  - `프로세스(process)`: 메모리에 로드한 프로그램
  
### 커널과 시스템 콜
- 커널(kernel)
  - OS의 핵심요소
  - 컴퓨터 하드웨어와 프로세스의 보안, 자원 관리, 하드웨어 추상화 같은 중요한 역할 수행
  - 자원관리: CPU 스케줄링, 메모리 관리, 입출력 관리, 파일 시스템 관리 등 담당
- 커널 모드(kernel mode)와 사용자 모드(user mode)
  - 커널 모드: 하드웨어에 직접 접근 → 메모리, CPU와 같은 자원 사용 가능
  - 사용자 모드: 커널 모드의 자원에 접근할 수 없도록 제한
- 시스템 콜(system call)
  - 사용자 모드에서 커널 모드에 접근해 필요한 기능을 수행할 수 있게 하는 시스템 함수
  - 커널은 시스템 콜로 받은 요청을 처리 후 다시 시스템 콜로 결과 값 반환
  - 프로세스 제어, 파일 조작, 장치 관리, 데이터 유지 보수, 통신, 보호 수행 가능
  - 예시
    - `fork()`: 프로세스 생성 함수
    - `wait()`: 부모 프로세스가 자식 프로세스의 수행을 기다리는 함수
  - 시스템 콜이 커널에 매개변수를 전달하는 방법
    1. 매개변수를 CPU의 레지스터에 직접 전달하는 방식
        - 매개변수의 개수가 레지스터의 개수보다 많은 경우 문제 발생 가능성 존재
    2. 매개변수를 메모리에 저장한 후 메모리의 주소 값을 레지스터에 저장하는 방식
    3. 매개변수를 프로그램의 스택(stack)에 push하고 OS에서 pop해 매개변수를 전달하는 방식
    
## 프로세스
### 프로세스
- 컴퓨터에서 실행 중인 하나의 프로그램을 의미
- 프로그램: 특정 작업을 수행하기 위한 명령어의 집합
- OS는 프로그램 실행 시, 디스크에 저장된 데이터를 메모리로 로드
  → 프로세스는 OS로부터 독립된 메모리 영역(코드, 데이터, 스택, 힙)을 할당 받음
  → 다른 프로세스의 메모리 영역 접근 불가

### 프로세스의 메모리 영역 구조
- 스택(stack): 지역 변수, 함수의 매개변수(parameter), 반환되는 주소 값 등이 저장되는 영역
  - 높은 주소 값에서 낮은 주소 값으로 메모리 할당
  - 영역 크기는 컴파일 때 결정
- 힙(heap): 사용자에 의해 동적 메모리 할당이 일어나는 영역
  - C 언어에서 `malloc()`으로 할당되는 영역
  - 낮은 주소 값에서 높은 주소 값으로 메모리 할당
  - 영역 크기는 런타임 때 결정
- 데이터(data): 전역 변수, 정적 변수, 배열, 구조체 등이 저장되는 영역
  - 세부적으로 `BBS(Block Stated Symbol) 영역`과 `데이터 영역`으로 다시 나뉨
    - BBS 영역은 초기화하지 않은 변수를, 데이터 영역은 초기화한 변수를 저장
- 코드(code): 실행할 코드가 기계어로 컴파일되어 저장되는 영역
  - `텍스트(text) 영역`이라고도 함

스택 영역과 힙 영역은 동적 메모리 할당이 가능하여 두 영역 사이에 빈 메모리 공간 존재
- 스택 영역: LIFO(Last In First Out, 후입선출) 방식, 높은 주소 값 → 낮은 주소 값 순서 사용
- 힙 영역: FIFO(First In First Out, 선입선출) 방식, 낮은 주소 값 → 높은 주소 값 순서 사용
- 메모리 영역을 공유하므로, 상호 영역 침범 문제 발생 가능
  - 스택 오버플로(stack overflow): 스택 영역이 힙 영역을 침범하는 경우
  - 힙 오버플로(heap overflow): 힙 영역이 스택 영역을 침범하는 경우
  
- 오버플로(overflow): 메모리 공간에서 할당할 수 있는 최대 범위를 넘어가는 것을 의미
- 언더플로(underflow): 메모리 공간에서 할당할 수 있는 최소 범위보다 작은 것을 의미

### 스레드(thread)
- 프로세스에서 실제로 실행되는 흐름의 단위
- 프로세스 내 존재 → 프로세스의 메모리 공간 이용, 지역 변수를 저장하는 스택 영역을 할당 받음 / 전역 변수를 저장하는 힙 영역은 다른 스레드와 공유

### PCB(Process Control Block, 프로세스 제어 블록)
- OS에서 프로세스를 제어하기 위해 저장한 프로세스 정보
- 프로세스 현재 상태, PID(Process ID), 부모 프로세스 PID, 자식 프로세스 PID, PC(Program Counter, 다음 실행 명령어 주소), 프로세스 우선순위, 메모리 제한 등 저장

### 프로세스 생성
- 새로운 프로세스: 기존 프로세스에서 `fork()` 함수를 호출하여 생성
- `fork()` 함수
  - 함수를 호출한 프로세스 복사 기능 존재
    - 기존 프로세스: 부모 프로세스(parent process)
    - 복사된 프로세스: 자식 프로세스(child process)
  - 부모 프로세스에서 `fork()` 함수 호출 시,
    - 부모 프로세스: 자식 프로세스의 PID 값 반환
    - 자식 프로세스: 0을 반환
    
### 프로세스 종료
- 운영체제가 프로세스를 종료하는 경우
  - 프로세스가 운영체제의 종료 함수(`exit()`)를 호출해 정상 종료하는 경우
  - 프로세스의 실행 시간 또는 특정 이벤트 발생을 기다리는 시간이 제한된 시간을 초과한 경우
  - 프로세스가 파일 검색 또는 입출력에 실패하는 경우
  - 오류 발생 또는 메모리 부족 등이 발생하는 경우
- 부모 프로세스가 자식 프로세스를 종료시키는 경우
  - 자식 프로세스가 할당된 자원을 초과해 사용할 때
  - 자식 프로세스에 할당된 작업이 없을 때
  
### 프로세스 상태도

- 생성(new): 프로세스가 PCB를 가지고 있지만 OS로부터 승인(admit) 받기 전
- 준비(ready): OS로부터 승인받은 후 준비 큐에서 CPU 할당을 기다림
- 실행(running): 프로세스가 CPU를 할당받아 실행함
- 대기(waiting): 프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 기다림
- 종료(terminated): 프로세스 실행을 종료함

####
- 생성 → 준비: 생성 상태의 프로세스가 OS로부터 승인을 받아, 준비 상태의 프로세스가 모여 있는 자료구조인 준비 큐(ready queue)에 추가됨
- 준비 → 실행: 준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 디스패치(dispatch)되어 실행됨
- 실행 → 준비: CPU 독점을 방지하기 위해 타임아웃(timeout)되어 준비 상태로 변경됨
- 실행 → 대기: 입출력 또는 이벤트 때문에 대기 상태로 변경됨
- 대기 → 준비: 입출력 또는 이벤트가 완료되어 준비 상태로 변경됨
- 실행 → 종료: 실행 중인 프로세스가 정상적으로 끝나서 종료 상태로 변경됨

### 멀티 프로세스와 멀티 스레드
- 동시성(concurrency): 하나의 코어(싱글 코어)에서 여러 작업을 번갈아 가면서 처리하는 방식
  - 콘텍스트 스위칭(context switching): 하나의 CPU에서 여러 작업을 번갈아 가면서 처리하기 위해 처리 중인 작업을 교체하는 것
- 병렬성(parallelism): CPU가 여러 개(멀티 코어) 있어서 각 CPU에서 각 작업을 동시에 처리하는 방식, 물리적인 시간 관점에서 동시에 여러 작업이 처리됨

### 멀티 프로세스
- 멀티 프로세스(multi process): 응용 프로그램 하나를 여러 프로세스로 구성하는 것
  - 멀티 프로세스 환경에서는 한 프로세스가 죽어도 다른 프로세스에 영향을 주지 않음
  - 응용 프로그램을 프로세스 하나로 구성하는 것보다 여러 개로 구성하는 것이 안정적
  - 단점: 시간, 메모리 공간을 많이 사용
- `오버헤드(overhead)`: CPU에서 기존에 처리하던 프로세스가 할당받은 메모리 영역을 다른 프로세스에서 사용할 수 있게 교체하면서 필요한 시간과 메모리를 의미
- IPC(Inter Process Communication): 프로세스 간 자원을 공유하기 위한 수단

### 멀티 스레드
- 멀티 스레드(multi thread): 스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것
  - 스레드 간에 힙, 데이터, 코드 영역 공유 → context switching 간에 오버헤드가 적게 발생, IPC 불필요 → 멀티 프로세스 단점 보완
  - 자원 효율성: 다중 프로세스 생성 < 다중 스레드 생성
  - 시스템 처리 비용: 스레드 간 자원 공유 < 프로세스 간 자원 공유
  - 프로그램 응답 시간: 스레드 간 < 프로세스 간
  - 단점
    - 공유 자원에 대한 동기화 필수
    - 스레드에 문제가 생기면 프로세스 내 다른 스레드에 영향 가능성
 
### 컨텍스트 스위칭
- 인터럽트(interrupt): CPU가 프로세스 처리 중에 입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것
  - 발생 상황
    - 입출력이 발생할 때
    - CPU 사용 시간이 만료되었을 때
    - 자식 프로세스를 생성할 때
- 컨텍스트(context): CPU가 처리하는 프로세스의 정보
- 컨텍스트 스위칭(context switching): 멀티 프로세스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것
- PCB에는 프로그램 카운터와 스택 포인터 값이 저장되어 있음 → 이전에 실행하던 코드를 이어서 실행 하능
  - 프로그램 카운터(PC, Program Counter): 프로세스가 이어서 처리해야 하는 명령어의 주소값
  - 스택 포인터(stack pointer): 스택 영역에서 데이터가 채워진 가장 높은 주소 값

### 프로세스 동기화
#### 경쟁 상태
- 공유 자원에 동시에 접근해 경쟁하는 상태 → 여러 프로세스 또는 스레드에서 하나의 공유 자원에 접근하는 경우, 자원에 접근 하는 순서에 따라 결과 값이 달라질 수 있음

#### 임계 영역
- 공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역
- 임계 영역에 여러 접근이 동시에 발생하는 것을 방지하기 위한 조건
  - 상호배제 기법(mutal exclusive): 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근할 수 없음
    - 상호배제 기법: 뮤텍스, 세마포어
  - 진행(progress): 임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행
  - 한정된 대기(bounded waiting): 임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않음

#### 뮤텍스(mutex)
- 락(lock)을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법
- 임계 영역에 먼저 접근한 프로세스가 임계 영역에 락을 걸면 다른 프로세스들은 해당 프로세스가 락을 해제하기 전까지 대기해야 함
- 스핀락(spinlock): 락을 얻기 위해 프로세스가 반복문을 돌면서 기다리는 것 → `바쁜 대기`의 일종 → 프로세스 교체 속도 빠름
- 락킹 매커니즘(locking mechanism)이라고도 함


- `바쁜 대기`: 프로세스가 공유 자원에 접근할 수 있는 권한을 얻을 때까지 확인하는 과정


#### 세마포어(semaphore)
- 공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법
- 시그널링 메커니즘(signaling mechanism)이라고도 함 → 공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보냄

#### *동기와 비동기
- 동기(synchronization): 여러 작업을 처리할 때 작업 순서를 보장함
- 비동기(asynchronization): 여러 작업을 처리할 때 작업 순서를 보장하지 않음

#### *블로킹과 넌블로킹
- 블로킹(blocking): 작업을 수행할 때 대기할 수 있다는 것을 의미, 작업 순서를 보장하지 않음
- 넌블로킹(non-blocking): 작업을 시작하면 대기 없이 수행한다는 것을 의미함

### 교착 상태(deadlock)
- 상호배제 기법 때문에 2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태
- 교착 상태 발생의 4가지 필요 충분 조건
  - 상호배제(mutal exclusion): 하나의 공유 자원에 하나의 프로세스만 접근할 수 있음
  - 점유와 대기(hold and wait): 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기
  - 비선점(non-preemption): 다른 프로세스에 할당된 자원을 뺏을 수 없음
  - 환형 대기(circular wait): 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구
- 교착 상태를 막는 방법
  - 상호배제 부정: 여러 프로세스가 동시에 하나의 공유 자원을 사용할 수 있게 함
  - 점유와 대기 부정: 프로세스가 실행되기 전에 필요한 모든 자원을 할당함으로써 프로세스 대기를 없앰. 또는 프로세스가 자원을 점유하지 않은 상태에서만 자원을 요구하게 함
  - 비선점 부정: 자원을 점유한 프로세스가 다른 자원을 요구할 때 점유한 자원을 반납하게 함
  - 환형 대기 부정: 자원을 선형 순서로 정렬해 고유 번호를 할당, 각 프로세스에서 요구할 수 있는 번호의 방향을 정해 한쪽 방향으로만 자원을 요구하게 함
  
### 스레드 안전(thread safe)
- 멀티 스레드 환경에서 하나의 변수, 함수, 객체에 스레드 여러 개가 동시에 접근해도 문제가 없음을 의미
- 스레드 안전을 위한 조건
  - 상호배제(mutal exclusive): 공유 자원에 접근해야 할 때 뮤텍스 또는 세마포어와 같은 상호배제 기법을 사용해 접근을 통제해야 함
  - 원자 연산(atomic operation): 공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 연산을 이용해 연산 도중에 다른 스레드가 접근할 수 없게 함
    - 원자 연산: `연산했다`와 `연산 안 했다` 두 가지만 존재하는 연산
  - 재진입성(reentrancy): 특정 함수를 하나의 스레드에서 실행 중일 때 다른 스레드가 해당 함수를 실행해도 각 스레드에 올바른 결과가 나올 수 있게 해야 함
  - 스레드 지역 저장소(thread local storage): 각 스레드에서만 접근할 수 잇는 저장소를 사용해서 공유되는 자원을 줄여야 함
  
### IPC(Inter Process Communication)
- 프로세스 간에 자원을 공유하는 방식
- IPC의 종류
  1. 공유 메모리(shared memory)
     - 프로세스 간에 공유 가능한 메모리를 구성해 자원을 공유하는 방식
     - 여러 프로세스에서 접근할 수 있으므로 동기화 문제 발생 가능
  2. 소켓(socket)
     - 네트워크 소켓을 이용하는 프로세스 간 통신으로, 외부 시스템과도 이용할 수 있음
     - 클라이언트(client)와 서버(server) 구조로 자원을 주고 받음
  3. 세마포어(semaphore)
     - 접근하는 프로세스를 제어해 공유 자원을 관리함
  4. 파이프(pipe)
     - FIFO(First In First Out) 형태의 메모리인 파이프를 이용해 프로세스 간 자원을 공유하는 방식
     - 파이프는 단방향 통신만 지원 → 읽기 또는 쓰기 중 하나만 할 수 있음
     - 양방향 통신을 하려면 읽기 파이프(read pipe)와 쓰기 파이프(write pipe)를 각각 생성해야 함
  5. 메시지 큐(message queue)
     - FIFO 형태의 큐 자료구조를 사용해 프로세스 간 메시지를 주고받는 방식
     
### 좀비 프로세스와 고아 프로세스
- 좀비 프로세스(zombie process): 자식 프로세스가 종료되었지만 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우에 남겨진 자식 프로세스
  - 자식 프로세스가 종료될 때 부모 프로세스에 `SIGCHLD`라는 시그널을 보내면 부모 프로세스에서 `wait()` 함수(시스템 콜)를 호출해 자식 프로세스의 상태 정보를 받고 자원 회수 → 자원 회수 실패 시 좀비 프로세스 발생 → 좀비 프로세스가 쌓이면 자원 낭비 초래
- 고아 프로세스(orphan process): 부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우의 자식 프로세스
  - 고아 프로세스 발생 시
    - 자식 프로세스의 부모 PID를 init 프로세스의 PID인 1로 바꿔줌 → 고아 프로세스의 부모 프로세스는 init 프로세스가 됨 → 고아 프로세스 작업 종료 시 init 프로세스가 고아 프로세스의 자원 회수 → 좀비 프로세스가 되는 것을 방지
    
## 스케줄링
### 스케줄링의 목적
- 목적: 멀티 프로세스 환경에서 모든 프로세스를 공평하게 실행 하는 것
  - 세부 목적
    - 공평성: 모든 프로세스가 공평하게 실행되어야 함, 특정 프로세스가 실행되지 않는 경우가 없도록 스케줄링해야 함
    - 효율성: 자원을 효율적으로 사용해 자원이 사용되지 않는 시간이 없도록 스케줄링 함
    - 안정성: 우선순위를 고려해 높은 우선순위의 프로세스를 먼저 처리하도록 스케줄링해야 함
    - 반응 시간 보장: 프로세스가 오랜 시간 응답이 없으면 사용자는 시스템이 멈춘 것으로 보기 때문에 일정 시간 내에 응답할 수 있도록 스케줄링 해야 함
    - 무한 연기 방지: 특정 프로세스에 대한 처리가 무한히 연기되지 않도록 스케줄링 해야 함
    
### 스케줄링의 단계
#### 장기 스케줄링(long-term scheduling)
- 준비 큐에 어떤 프로세스를 넣을지 결정해 메모리에 올라가는 프로세스 수를 조절
- 잡 스케줄링(job scheduling) 또는 승인 스케줄링(admission scheduling)이라고도 함
- 현대 운영체제에서는 대부분 사용하지 않음 → 시분할 시스템 사용
#### 중기 스케줄링(mid-term scheduling)
- 메모리에 로드된 프로세스 수를 동적으로 조절
  1.  메모리에 프로세스가 많이 로드되면 스왑 아웃(swap out)해서 일부 프로세스를 통째로 저장
  2. 스왑 아웃된 프로세스는 중단 상태(suspended)가 됨
  3. 중단 상태는 준비 상태에서 스왑 아웃된 `중단된 준비 상태`와 대기 상태에서 스왑 아웃된 `중단된 대시 상태`로 구분
#### 단기 스케줄링(short-term scheduling)
- 준비 큐에 있는 대기 상태 프로세스 중 어떤 프로세스를 다음으로 실행할지 스케줄링 알고리즘으로 결정 ← 어떤 프로세스를 디스패치할지 결정
- CPU 스케줄링이라고도 함

#### *스왑(swap)
- 스왑 아웃(swap out): 메모리 공간보다 많은 프로세스가 로드되는 경우, 중기 스케줄러가 이벤트 발생을 기다리고 있는 프로세스를 통째로 저장 공간(HDD, SSD와 같은 영역)으로 옮겨 저장하는 것
- 스왑 인(swap in): 스왑 아웃한 프로세스에서 이벤트 요청이 오면 해당 프로세스를 통째로 다시 메모리에 로드하는 것
- 스와핑(swapping): 스왑 아웃과 스왑 인처럼 프로세스를 통째로 메모리 영역과 저장 공간으로 옮기는 것
  - 장점: 메모리 공간보다 많은 프로세스를 실행할 수 있음

### 스케줄링 알고리즘
- CPU 스케줄러(단기 스케줄러)가 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬지 결정하는 데 사용
- 스케줄링의 목적 달성을 위한 평가 기준
  - CPU 사용률: CPU를 놀리지 않고 사용하는지 판단
  - 처리량: 단위 시간(time unit)당 실행한 프로세스 수
  - 응답 시간: 프로세스에 요청이 발생했을 때 응답까지 걸리는 시간
  - 반환 시간: 프로세스가 로드된 이후부터 종료될 때까지 걸리는 시간
  - 대기 시간: 프로세스가 대기 큐에서 대기하는 시간의 총합
  
#### 비선점형 스케줄링
- 실행 중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없음을 의미
  - 종류
    - FCFS 스케줄링: 준비 큐에 먼저 들어온 프로세스가 우선순위를 갖는 알고리즘
      - 준비 큐에 먼저 들어온 프로세스(first come)를 먼저 실행(first served)
    - SJF 스케줄링: 실행 시간이 짧은 프로세스가 우선순위를 갖는 알고리즘
      - SJN(Shortest Job Next) 스케줄링이라고도 함
      - 준비 큐에 있는 프로세스 중 CPU를 점유하는 실행 시간이 가장 짧은 프로세스(shortest job)부터 실행
      - 평균 대기 시간이 가장 짧지만, 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에 밀려 기아 상태가 될 수 있음

`기아 상태(starvation)`: 프로세스마다 우선순위(priority)가 있는데, 우선순위가 높은 프로세스만 수행되어 우선순위가 낮은 특정 프로세스는 계속 실행되지 못하는 것을 의미

#### 선점형 스케줄링
- 스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있음을 의미
  - 종류
    - RR 스케줄링: 모든 프로세스를 순서대로 일정 시간동안 실행, 일정 시간 초과 시 다른 프로세스 실행
      - 일정 시간 - '시간 단위'를 의미, 타임 퀀텀(time quantum) 또는 타임 슬라이스(time slice)라고도 함
      - 시간 단위: 일반적으로 10~100ms
      - context switching이 빈번하게 발생 → 오버헤드가 크다는 단점 존재, 모든 프로세스가 반복 수행되어 응답 속도가 빠르다는 장점
    - SRTF 스케줄링: 준비 큐에서 대기 시간이 가장 짧게 남은 프로세스(shortest remaining time)를 우선 수행(first)하는 알고리즘
      - 한 프로세스가 실행 중일 때 실행 시간이 더 짧은 프로세스가 준비 큐에 들어오면 실행 시간이 더 짧은 프로세스가 CPU를 차지
      - 장점: 평균 대기 시간이 짧음
      - 단점: 수행 시간이 긴 프로세스는 기아 상태가 되기 쉬움
    - 멀티 레벨 스케줄링: 준비 큐를 목적에 따라 여러 개로 분리해 사용하는 알고리즘
      - 분리한 큐는 각각 우선순위 존재, 각자 다른 스케줄링 알고리즘 적용 가능
        - foreground 큐: 응답 속도가 중요한 프로세스가 들어감
        - background 큐: 응답 속도보다 성능을 중요시하는 프로세스가 들어감

## 메모리 관리 전략
### 논리 메모리와 물리 메모리
- 논리 메모리 영역(logical memory address space): 프로세스가 보는 메모리 영역
  - 가상 메모리 영역(virtual memory address space)라고도 함
- 물리 메모리 영역(physical memory address space): 실제로 사용되는 메모리 영역(RAM)
- 논리 주소(logical address): CPU가 프로세스를 실행하며 보는 주소 값, 가상 주소(virtual address)라고도 함
- 물리 주소(physical address): 실제 메모리에서 사용되는 주소

#### 메모리 관리 장치
- 메모리 관리 장치(MMU, Memory Management Unit): 논리  주소를 물리 주소로 변환해 주는 하드웨어 장치
- CPU 내에 위치
- CPU에서 메모리에 접근하기 전에 MMU를 거쳐 논리 주소에 해당하는 물리 주소를 얻음
- 보호해야 하는 메모리 영역에 대한 접근 제한 → 메모리 보호 역할 수행

### 연속 메모리 할당(contiguous allocation)
- 멀티 프로세스 환경에서 여러 프로세스를 메모리에 연속적으로 로드하는 방법
#### 고정 분할 방식
- 메모리 영역을 분할한 뒤 각 영역에 프로세스를 할당하는 방식
- 분할된 영역의 크기는 서로 다를 수 있음, 분할된 크기는 고정
- 단점: 메모리에 올릴 수 있는 프로세스의 수와 각 프로세스 크기가 제한됨, 단편화(fragmentation) 문제 발생 가능
  - 외부 단편화(external fragmentation): 할당 해야할 프로세스 크기보다 분할된 크기가 더 작을 때 발생
  - 내부 단편화(internal fragmentation): 분할된 크기보다 작은 프로세스가 할당되어 메모리 공간이 남는 경우
  
#### 가변 분할 방식
- 할당할 프로세스의 크기에 따라 메모리 공간을 분할하는 방식
- 메모리 할당 알고리즘을 이용해 가용 메모리 공간에서 프로세스가 로드될 수 있는 메모리 공간을 찾음
- 메모리 할당 알고리즘
  - 최초 적합(first-fit): 가용 메모리 공간에서 프로세스 크기만큼 비어 있는 메모리 공간을 찾아 차례대로 프로세스를 로드하는 방식
  - 최적 적합(best-fit): 할당하려는 프로세스 크기 이상인 가용 메모리 공간 중에서 가장 작은 공간에 프로세스를 할당하는 방식
    - 가용 메모리 공간을 모두 탐색해야 함
  - 최악 적합(worst-fit): 할당하려는 프로세스 크기보다 큰 가용 메모리 공간 중에서 가장 큰 공간에  프로세스를 할당하는 방식
    - 가용 메모리 공간을 모두 탐색해야 함

#### 메모리 압축
- 프로세스가 사용 중인 메모리 공간을 재배치해서 흩어져 있는 가용 메모리 공간을 합치는 것
- 메모리 집약이라고도 함

### 비연속 메모리 할당
- 프로세스의 메모리 영역을 나눠서 메모리 공간에 저장하는 방법
#### 페이징(paging)
- 프로세스의 논리 메모리 영역과 물리 메모리 영역을 각각 일정한 크기의 페이지(page)와 프레임(frame)으로 나눔
  - 페이지와 프레임의 크기는 동일
- 페이지와 프레임별로 번호를 할당해 프로세스의 페이지와 메모리의 프레임을 매핑
- 페이지 테이블(page table)
  - 프로세스의 페이지 정보와 페이지에 매핑하는 프레임의 주소 값을 저장
  - 페이지 테이블은 각 프로세스의 PCB에 저장
- 페이지를 물리 메모리에 연속으로 할당할 필요가 없어서 외부 단편화 문제 해결 가능
  - 프로세스 크기가 페이지 수로 나누어 떨어지는지는 보장하지 않음
  - 프로세스의 마지막 페이지가 페이지 크기보다 작을 수 있음 → 내부 단편화 문제 발생 가능
  - 페이지 테이블을 저장하기 위한 메모리 공간을 추가로 소요

#### *페이징 기법
- 계층적 페이징(hierarchical paging): 페이지 테이블을 다시 페이지로 나눠 페이지 테이블 자체를 페이징하는 방식, 멀티 레벨 페이징(multi-level paging)이라고도 함
- 해시 페이지 테이블(hashed page table): 해시 테이블의 각 항목에 저장된 연결 리스트에 페이지 번호를 해싱(hashing)한 뒤에 첫 번째 요소와 가상 페이지 번호를 비교하는 방식
- 역 페이지 테이블(inverted page table): 프레임을 이용해 페이지를 찾는 방식, 페이지로 프레임을 찾는 기존 방식과 반대

#### 세그먼테이션(segmentation)
- 프로세스의 메모리 영역을 논리적 단위인 세그먼트로 분할해 메모리를 할당하는 방식
  - 논리적 단위: 파일 내 함수 단위, 프로세스의 스택, 힙과 같은 영역을 의미하기도 함
- 세그먼테이션 테이블(segmentation table)을 사용해 세그먼트의 논리 주소를 물리 주소로 매핑
- 세그먼트 테이블은 세그먼트 번호를 인덱스로 사용
  - 세그먼트별 시작 주소인 base와 세그먼트 길이인 limit를 저장
- 장점: 프로세스의 메모리 영역을 논리적 단위로 나눠 저장하므로 단위별로 데이터를 보호하기 쉬움
- 단점
  - 세그먼트의 크기가 균등하지 않아서 프로세스의 할당/해제를 반복하는 과정에서 외부 단편화 문제 발생 가능
  - 메모리에 로드된 스택 세그먼트 영역에서 오버플로가 발생하면 다른 프로세스와 메모리 영역이 겹칠 수 있음
    → 다른 프로세스의 세그먼트나 스택 오버플로가 발생한 세그먼트를 디스크로 스왑 아웃해야 함

## 가상 메모리
### 가상 메모리의 개념
- 프로세스의 일부만 메모리에 로드하고, 나머지는 디스크에 둔 상태로 프로세스를 실행하는 방식
  - 프로세스 전체가 메모리에 올라오지 않아도 프로세스를 실행하는 데 문제가 없다는 점에서 착안
- 장점
  - 프로그램이 메모리 크기에 대한 제약을 덜 받을 수 있음
  - 동시에 많은 프로그램을 실행하므로 CPU 이용률과 처리율을 높일 수 있음
  - 필요한 영역만 메모리에 로드해 스와핑 횟수를 줄여서 프로그램 실행 속도를 높일 수 있음

### 요구 페이징(demand paging)
- 프로세스에서 필요한 페이지만 메모리에 로드하는 방식
- 페이지를 모두 메모리에 로드하지 않고 초기에 필요한 영역만 로드한 후 다른 영역은 요청이 올 때 메모리에 로드

#### 페이지 폴트(page fault)
- 프로그램을 실행 중 물리 메모리에 필요한 페이지가 없는 경우를 말함
- 페이지 폴트 발생 시, 디스크에서 필요한 페이지를 스왑 인 함 → 페이지에 해당하는 메모리 영역이 물리 메모리에 있는지는 페이지 테이블로 파악
- 페이지 테이블
  - 페이지에 해당하는 프레임 존재 시 → 'v(valid)' 값 반환
  - 미존재 또는 유효하지 않은 주소일 경우 → 'i(invalid)' 값 반환
  
#### 페이지 폴트 발생 시 처리 과정
1. 필요한 페이지가 물리 메모리에 있는지 없는지를 페이지 테이블에서 확인 → 페이지 폴트 발생 시, `i` 반환
2. `i`를 반환하면 OS는 참조하려는 페이지의 주소 값이 유효하지 않은지 아니면 메모리에 로드되지 않은 영역인지 판단
3. 필요한 페이지가 메모리에 로드되지 않은 영역이라면 디스크에서 해당 영역을 찾음
4. 디스크에서 해당 페이지 영역을 스왑 인
물리 메모리에 비어 있는 프레임(free frame)이 있으면 페이지를 해당 영역에 바로 로드
비어 있는 프레임이 없으면 페이지 교체 알고리즘(page replace algorithm)을 호출해 기존에 로드된 페이지를 디스크로 스왑 아웃한 후 새로운 페이지를 로드
5. 페이지 테이블에서 새로 로드한 페이지의 값을 `v`로 변경
6. 프로세스를 다시 실행

### 스레싱(thrashing)
- 동시에 일정 수 이상의 프로그램을 실행했을 때 오히려 CPU 이용률이 떨어지는 상황을 말함
- 일정 수 이상으로 다중 프로그래밍을 하면 페이지 폴트가 자주 발생 → 디스크 영역에서 필요한 페이지 스왑 인, 불필요한 페이지 스왑 아웃 작업 빈번
- 예방법: `워킹 세트(working set)` 설정 → 자주 사용하는 페이지를 물리 메모리의 프레임에 고정 → 빈번한 페이지 폴트 발생 방지 가능
- 워킹 세트: 지역성을 기반으로 자주 사용하는 페이지를 저장해두는 것

## 캐시 메모리
### 캐시 메모리와 지역성
- 캐시 메모리(cache memory): CPU와 메인 메모리 간에 데이터 접근 시 속도 차이를 줄이기 위해 사용
  - CPU에서 메인 메모리에 있는 데이터를 가져올 때 자주 사용하는 데이터는 캐시 메모리에 따로 저장 → 메인 메모리에 접근하는 것 보다 속도가 빠름
- 캐시 메모리에 저장 하는 데이터의 기준: 지역성을 바탕으로 결정 → 캐시 적중률 ↑
- 지역성(locality): CPU가 자주 참조하는 데이터가 고르게 분포되지 않고 특정 부분에 몰려 있는 것
  - 시간 지역성(time locality): 최근 참조한 내용을 다시 참조할 가능성이 높음
  - 공간 지역성(space locality): 실제 참조한 주소 근처의 내용을 참조할 가능성이 높음

### 캐시 메모리의 매핑 방식
#### 직접 매핑(direct mapping)
- 메인 메모리를 일정한 크기로 나누고 각 영역을 캐시 메모리에 매핑하는 방식
  - 메인 메모리는 캐시 메모리보다 크므로 나눠진 n개의 메모리 영역이 1개의 캐시 메모리에 매핑됨
#### 연관 매핑(associative mapping)
- 메모리 영역을 캐시 메모리에 규칙없이 매핑하는 방식
  - 메모리 영역을 캐시 메모리에 적재할 때는 간단하지만, 캐시 메모리에서 필요한 메모리 영역을 찾을 때는 비효율적
#### 집합 연관 매핑(set associative mapping)
- 직접 매핑과 연관 매핑을 결합해 단점을 보완한 방식으로, 범용적으로 사용됨