
![](https://i.imgur.com/RPh5tZQ.png)

## 선형 자료구조:
- 연속적으로 데이터가 나열되는 구조
	- 배열, 리스트, 스택, 큐

## 배열(Array)
- 
  ![](https://i.imgur.com/GSx3Avt.png)

- 정해진 크기만큼 데이터가 일렬로 저장
- 정적 자료구조: 배열의 크기는 한번 정하면 크기를 변경 할 수 없다
- 각 데이터: 배열의 요소, 데이터를 가리키는 번호: 인덱스(배열 크기-1까지 가능)
- 기억장소 이용 효율은 밀도가 1로서 가장 좋다
- **`Cache hit`** 가능성이 커져 성능에 큰 도움
	- CPU가 참조하고자 하는 메모리가 캐시에 존재하고 있을 경우
- 접근
	- 임의접근: 특정 인덱스 기준으로 접근할 시 O(1)
	- 순차접근: 특정 데이터 기준으로 접근할 시 O(n)
- 삽입/삭제
	- 마지막 값을 제외한 위치에 삽입할 때: 뒤에 있는 값이 다 밀리거나 당겨지므로 O(n)
	- 마지막 공간에 삽입/삭제할 시 O(1)
## 연결리스트
- 
- ![](https://i.imgur.com/G6NnKsq.png)

- 여러 개의 노드로 구성
- 각 노드는 데이터와 다음 노드가 저장된 주소값 보유
	- 한 노드당 4Byte의 크기
	- 헤드 포인터: 리스트의 시작
	- 테일 포인터: 리스트의 끝, NULL을 가리킴
- **`cache hit`** 가 어려움
	- 순차성을 보장하지 못하기 때문에 **Spatical locality** 보장이 되지 않음
		- 최근 접근했던 주소 근처의 주소들을 접근하는 경향
- 동적 자료구조: 크기가 정해지지 않어 확장 가능한 구조
	- 기억공간이 연속적으로 놓여있지 않아도 저장이 가능
- 접근
	- 접근: 인덱스가 없기 때문에 불가
	- 검색: 특정 데이터 기준으로 접근할 시 O(n)
- 삽입/삭제
	- 데이터를 추가하는 연산 자체는 O(1)
	- 데이터가 적절한 위치로 이동되기까지 O(n)![](https://i.imgur.com/C0npZCR.png)
- 중간 노드의 연결이 끊어지면 그 다음 노드를 찾기 힘들다.

## 연결 리스트의 종류
- 단일(단순) 연결 리스트
- 
- 이중 연결 리스트
	- ![](https://i.imgur.com/uUDslHA.png)
	- 앞 노드와 다음 노드의 주소값을 모두 저장
	- 구현하기 어려움
	- 메모리를 많이 차지
	- 연결 순서 무관하게 탐색 시 효율적
- 원형 연결 리스트
	- ![](https://i.imgur.com/UNd0Anp.png)
	- 마지막 노드가 첫번째 노드의 주소값을 가리킴
	- 가장 처음이나 끝에 삽입 시 상수 시간 소요
	- 탐색 코드를 잘못 따면 루프에 빠질 수 있음


## 스택
- 데이터를 쌓는 형태:LIFO 구조
- ![](https://i.imgur.com/toHAayH.png)

- 삽입(push)/삭제(pop) 연산을 O(1)로 가능하지만, 마지막 데이터만 접근 가능
- top: 데이터를 마지막으로 저장한 인덱스 
- 함수 호출, 스케줄링 등 다양한 부분에서 사용
- 크기를 늘릴 수 있는 가에 따른 여부
	- 정적 스택: 배열이용
	- 동적 스택: 리스트이용
## 큐
데이터가 순차적으로 들어오는 형태: FIFO 구조![](https://i.imgur.com/Fl1I7w8.png)
- 앞부분을 front, 뒷부분을 rear
	- 앞에서 삭제(dequeue)하고 뒤에서 삽입(enqueue)
- 프로세스 할당 큐 등, 대기 중인 작업일 때 사용
- 크기를 늘릴 수 있는 가에 따른 여부
	- 정적 큐: 배열이용
	- 동적 큐: 리스트이용
- 원형 큐: 배열의 시작과 끝이 구분되지 않아 삽입/삭제를 유연하게 수행 가능
- 덱: 양쪽 끝에서 삽입/삭제가 모두 가능
- 우선순위큐
    - 큐에 모든 요소에는 우선순위가 있으며 우선순위가 높은 요소는 우선순위가 낮은 요소보다 먼저 삭제