# 4.2.3 스택 ★★★
- 데이터를 쌓는 형태
- 마지막에 들어온 데이터가 먼저 나가는 LIFO(Last In First Out, 후입선출) 형태의 자료구조
 ![](https://i.imgur.com/s1Ne2aK.png)
_스택 구조_
- 연산
	- 데이터를 삽입 / PUSH
		- 데이터가 가장 위에 저장된다.
	- 데이터를 삭제 / POP
		- 가장 마지막에 저장한 데이터가 삭제된다.
- 데이터를 마지막으로 저장한 인덱스를 기억
	- push나 pop 연산을 할 때 배열을 이용해도 O(1)의 시간 복잡도로 마지막데이터에 접근
- 스택을 구현할 때는 배열과 연결 리스트를 이용
![](https://i.imgur.com/top9hY5.png)
_스택의 연신 및 시간 복잡도_
- 스택의 대표적인 예
	- 작업의 실행을 취소할 때 (최근에 처리한 작업들을 하나씩 꺼낼 때 사용)
	- 웹 브라우저에서 뒤로가기를 할 때

# 4.2.4 큐 ★★★
- 데이터가 순차적으로 들어오는 형태
- 먼저 들어온 데이터가 먼저 나가는 FIFO 형태의 자료구조 
![](https://i.imgur.com/htLEwzP.png)
_큐 구조_
- 큐의 맨앞 front /  맨 뒤 rear
- 데이터 삽입 / 인큐
	- 데이터가 큐의 맨 뒤에 삽입된다.
- 데이터 삭제 / 디큐
	- 데이터가 큐의 맨 앞에서 삭제된다.
- 배열과 연결리스트를 이용해 구
![](https://i.imgur.com/OWB3dRr.png)
- 큐의 대표적인 예
	- 운영체제에서 프로세스가 CPU를 할당 받기 전까지 대기하는 준비큐
	- 작업 요청이 들어온 순서대로 처리하기 위해 사용

## 하나 더 알기
- 큐를 배열로 구현하면 rear의 인덱스를 이용해 큐가 가득 찼는지 쉽게 확인 가능
- 인큐 또는 디큐를 수행할 때 front나 rear만 수정하면 된다.
![](https://i.imgur.com/LS4x7fY.png)
_배열 큐에서의 연산_
- 한계점
	- 데이터 삽입 연산으로 큐를 꽉 채운뒤, 1개만 남기고 삭제 연산을 수행하면 rear 인덱스를 보고 데이터가 가득 찼다고 생각할 수 있다.
 ![](https://i.imgur.com/dYdt4WR.png)
_배열 큐 구현 시 한계점_
- 이 문제를 해결하려고 인큐나 디큐를 수행할 때 데이터의 위치를 옮기면 시간 복잡도가 늘어나는 또 다른 문제가 발생
	-  순환 큐(circular queue)가 등장했다.
- 순환 큐를 구현하면 앞에서와 같은 상황에서 삽입 연산을 할 때 배열을 앞부분에 데이터를 삽입한다.
- 순환큐를 구현하면 배열의 시작과 끝이 구분되지 않아 데이터의 삽입과 삭제를 유연하게 수행할 수 있다.
![](https://i.imgur.com/8sRtG6R.png)
_순환 큐 구조_
![](https://i.imgur.com/wpWAzNg.png)
_원형 큐 구조_

## 깊게 알기 덱
- 덱은 양쪽 끝에서 데이터의 삽입과 삭제가 모두 가능한 자료구조
- 큐와 스택을 합친 상태
![](https://i.imgur.com/Accwuoa.png)
_덱 구_