TCP와 UDP의 전송 계층의 대표적인 프로토콜.
서비스를 개발할 때 어느 프로토콜을 사용해야 용이할까?

# 2.2.1 TCP란? ★★★
전송 계층에 해당하는 네트워크 프로토콜.
연결형 서비스를 지원하고 데이터의 신뢰성을 보장.
- 패킷 교환 방식은 패킷이 전달되는 회선이 정해져 있는 가상회선 방식
- 패킷의 전송 순서 보장
- 패킷의 수신여부 확인
- 송신부와 수신부는 1:1 통신
- 데이터의 손실이 없음을 보장. 신뢰성이 높다.
- 데이터의 송수신 속도가 느리다.

# 패킷 교환 방식
- 데이터 통신 방식
	- 가상 회선 방식
		- 패킷을 전송할 경로인 가상회선을 설정
		- 모든 패킷을 같은 경로로 전송
	- 데이터그램 방식
		- 패킷마다 최적의 경로로 전송
		- 보낸 패킷 순서와 도착 패킷의 순서가 다를 수 있음

# 2.2.2 TCP 핸드셰이킹 ★★★
TCP에서는 연결형 서비스를 지원하기 위해 송신부와 수신부를 연결하는 과정을 거친다.
- 연결을 시작할 때는 3 -way 핸드셰이킹
- 연결을 종료할 때는 4 -way 핸드셰이킹
송신부와 수신부간에 플래그(flag) 값을 주고 받는다
## 주요 플래그 값(flag)
전부 영어 약자이다. 주로 SYN,FIN, ACK가 사용된다
- SYN
	- 동기화(Synchronization), 연결을 생성할 때 사용
- FIN
	- 종료(Finish), 연결을 끊을 때
- ACK
	- 승인(Acknowledgment), 수신자가 데이터를 받았을을 알려줌
- RST
	- 초기화(Reset), 연결을 재설정할 때 사용
- PSH
	- 밀다(Push), 빠른 응답이 필요한 데이터를 응용 계층으로 즉시 전송할 때 사용
- URG
	- 긴급(Urgent), 다른 데이터보다 우선순위가 높은 데이터를 전송 할 때 사용

## 3 -way 핸드셰이킹
데이터를 주고 받기전에 상대방 컴퓨터와 세션을 수립하는 과정
정확한 전달을 위해 필요
송신부/수신부
요청/응답
송신부와 수신부 모두 데이터를 주고받을 준비가 되었음을 보장

![](https://i.imgur.com/ux5oEn5.png)
_TCP 3 -way 핸드셰이킹_

1. 송신부가 수신부와 연결하기위해 SYN 메세지를 보낸다. 이때 임의의 숫자 N을 함께 보낸다. 응답이 오기전까지 SYN_SENT 상태
2. 수신부가 SYN 메세지를 받으면 ACK 메시지를 전송한다. ACK 메시지에는 1번에서 받은 N에 1을 더한 값을 보낸다. 반대로 연결을 확인하기위해 임의의 숫자 M을 보낸다. 응답을 기다리는 상태가 된다. SYN_RECEIVED
3. 송신부가 ACK + SYN 메세지를 받으면 연결이 성립되었다는 의미인 established 상태가 된다. 메시지에 대한 응답으로 ACK 메시지와 수신부로부터 받은 M에 1을 더해 보낸다. 이때 ACK 메시지에는 송신부에서 전송하려는 데이터가 포함될 수 있다. 송신부로부터 ACK메시지를 받으면 수신부는 established 상태가 된다.

## 4 -way 핸드셰이킹
TCP 연결을 해제할 때 이뤄지는 과정
![](https://i.imgur.com/vlbl3C6.png)
_TCP 4 -way 핸드셰이킹_

1. 연결을 종료하려고 FIN 메시지를 보낸다. FIN_WAIT1 상태가 된다.
2. 응답으로 ACK 메시지를 보낸다. CLOSE_WAIT 상태가 된다. 수신부는 메시지를 보낸 후 앱을 종료하는 등 연결을 종료하기 위한 작업을 한다. 송신부에서는 수신부에서 보낸 ACK 메시지를 받고 FIN_WAIT2 상태가 된다.
3. 수신부에서 연결을 종료할 준비가 끝나면 송신부에 FIN 메시지를 보내고 LAST_WAIT 상태가 된다.
4. 송신부는 서버로부터 받은 FIN 메시지에 응답하기 위해 ACK 메시지를 보내고 TIME_WAIT 상태가 된다.  일정 시간이 지나면 CLOSED 상태가 된다.
- 일정 시간을 유지하는 이유?
	-  패킷 유실에 대비하기 위해서 (FIN 메시지전에 보낸 패킷이 FIN 메시지 수신보다 지연되어 발생)
	- 수신부에 ACK 메시지가 제대로 전달되지 않아 연결 해제가 이뤄지지 않는 경우도 대비
5. 수신부는 송신부로부터 ACK 메시지를 받고 CLOSED 상태가 된다.

### 하나 더 알기
- 세션이 연결되면 이를 유지하기위해 일정시간이 경과한 후 TCP Keep Alive 패킷을 던져 연결 유지 상태를 확인할 수 있다. 
- TCP Keep Alive 패킷은 연결을 유지하길 원하는 쪽에서 보낸다. 
	- 패킷에 대한 응답을 받으면 시간을 처음부터 다시 측정하고, 응답을 받지 못하면 연결을 종료한다. 
- 이는 동일한 송신부로부터 재요청이 오는 경우에 불필요한 3 -way 핸드셰이킹을 줄일 수 있다.
- FIN 메시지를 받지 못한 경우에 발생할 수 있는 불필요한 연결, 즉 좀비 커넥션을 방지할 수 있다.

# 2.2.3 TCP 제어 방법 ★★★
신뢰성을 보장하기위한 제어 방법. (= 데이터 손실을 방지하기위한 방법)
흐름 제어(송수신할 때 제어)
혼잡 제어(혼잡이 발생할 때 제어)
오류 제어(오류가 발생할 때 제어)

## 흐름 제어
- 데이터 손실을 방지하는 방법
	- 데이터 송신부와 수신부에서 데이터 처리속도의 차이 때문에
### 1. 정지-대기(stop-wait)
- 송신부에서 데이터를 보낸 후 수신부로부터 ACK 메시지를 받을 때까지 다음데이터를 보내지 않고 기다리는 방식
- 송신부에서 패킷을 보내고 일정 시간 동안 수신부로부터 ACK 메시지를 받지 못하면 패킷을 재전송
- 간단하지만, 이전 메시지에 대한 응답을 받아야만 다음 메시지를 보낼 수 있어서 시간 면에서 비효율적
 ![](https://i.imgur.com/d1Ao6Hm.png)
_정지-대기 작동방식_

### 2. 슬라이딩 윈도우(sliding window)
송신자가 한 번에 보낼 수 있는 데이터 패킷의 수를 제한하는 기법
- 이 제한된 수의 패킷들을 윈도우(window)라고 부른다. 
	- 윈도우 크기는 고정되거나 동적으로 조정될 수 있으며, 송신자는 이 윈도우 내에서만 데이터를 전송할 수 있다.
- 송신부에서 데이터의 수신 여부(ACK)를 확인하지 않고 수신부에서 설정한 윈도우 크기만큼 데이터를 연속적으로 보낼 수 있게 해서 데이터 흐름을 동적으로 제어하는 방식
- 3 -way 핸드셰이킹 과정에서 정해진다
- 정지-대기 방식의 단점을 보완 (ACK메시지를 받지않아도 다음 메시지를 보낼 수 있어서)

![](https://i.imgur.com/Ope16D9.png)
_슬라이딩 윈도우 예제_

## 혼잡 제어
- 데이터 손실이 발생하는 것을 방지.
	- 송신부의 데이터 전달 속도와 네트워크 속도 차이로인해 
- 혼잡은 네트워크에 패킷 수가 과도하게 증가하는 증상을 의미.
	- 혼잡이 발생해 네트워크에 패킷이 쌓이면서 일정 시간 응답을 받지 못하면, 송신부에서는 메시지 전송에 실패했다고 판단해 수신부에 패킷을 재전송. 이는 혼잡을 가중해 악순환을 야기한다.
- 따라서 TCP는 혼잡 윈도우의 크기를 조절해 혼잡에 대응

### 1. AIMD(Additive Increase Multiplicative Decrease)
1. 데이터를 전달할 때 합 증가(additive increase) 방식으로 혼잡 윈도우의 크기를 더해가면서 키운다.
2. 데이터 손실이 발생하면 혼잡 윈도우의 크기를 곱 감소(multiplicative decrease) 방식을 적용해 1/2배와 같이 배수 단위로 줄인다.
![](https://i.imgur.com/9mhBTaC.png)
_AIMD에서 시간에 따른 혼잡 윈도우 크기 변화_
- AIMD 방식은 시간이 지나면 여러 송신부 간에 네트워크 대역폭을 공평하게 사용할 수 있게 된다.
- 하지만 데이터 유실이 발생하면 윈도우 크기 증가폭 대비 윈도우 크기 감소폭이 크기 때문에 네트워크의 대역폭을 넓게 사용하기까지 시간이 오래 걸린다는 단점이 있다.

### 2. 느린 시작(slow start)
1. 윈도우 크기가 1인 상태에서 시작해 ACK 메시지를 수신할 때마다 윈도우 크기를 1씩 늘려나간다.
2. 혼잡이 발생하면 윈도우 크기를 1로 확 줄이는 방식.
- 패킷 1개에대한 ACK 메시지를 받으면 다음에는 2개를 보낸다.
- 다시 ACK 메시지를 받으면 4개를 보낸다. 
- 이처럼 보낼 수 있는 지수함수 형태로 증가한다
![](https://i.imgur.com/uRluoo6.png)
_느린 시작의 예_
- 느린시작?
	- 처음부터 최대 개수만큼 보내는 것이 아니라 1개부터 점차 늘려가서
- 전송 가능한 패킷 수(윈도우 크기)를 지수 함수 형태로 늘린다.
	- AIMD 방식에서 초기에 전송 가능한 패킷 수가 적다는 단점을 보완

### 3. 혼잡 회피(congestion advoidance)
- 윈도우 크기에 대한 임계점(threshold)을 정하는 방식
	- 윈도우 크기가 지수 함수 형태로 증가하다가 혼잡이 발생하는 것을 방지
- 윈도우 크기가 임계점에 도달하면 윈도우 크기를 선형적으로 증가하게 한다.
- ACK 메시지를 받지 못해 타임아웃이 발생하면 타임아웃이 발생한 시점에서 윈도우 크기의 절반을 임게점으로 설정하고, 윈도우 크기를 초깃값으로 변경한다.
### 4. 빠른 회복(fast recovery)
- 혼잡이 발생하면 혼잡 윈도우 크기를 절반으로 줄인 후 선형적으로 증가하는 방식.
- 즉, 혼잡이 처음 발생하면 AIMD 방식으로 동작한다.

### 5. 빠른 재전송(fast retransmit)
- Duplicate ACK가 3번 발생하면 해당 시점의 윈도우 크기를 1/2로 줄인다.
- 그 뒤로 ACK 메시지를 받으면 다시 윈도우 크기를 키우는 방식
- Duplicate ACK?
	- 패킷이 순서대로 도착하지 않아서 받아야 할 차례의 패킷을 ACK 메시지와 함께 요청하는 것을 뜻함
- Duplicate ACK가 3번 발생하면 혼잡이 발생했다고 판단해 윈도우 크기를 조정한다.
- 예를 들어, 송신부에서 패킷 0부터 5까지 보냈지만, 수신부에는 패킷 2가 오지 않았다. 수신부에서는 패킷 3, 4, 5에 대해 패킷 2를 보내라고 응답한다. 해당 응답이 3번 반복되면 송신측에서는 패킷 2를 재전송한다. 이때 윈도우 크기는 1/2로 줄어든다.
![](https://i.imgur.com/JKwNXk4.png)
_빠른 재전송 예_

### 깊게 알기 | TCP 혼합 제어 정책
TCP Tahoe, TCP Reno
- 두 방식 모두 느린 시작방식을 사용하다 임계점을 넘어가며 AIMD 방식으로 전환.
	- 여기서 임계점은 느린 시작 방식의 임계점 ssthresh(slow start threshold)
#### 1. TCP Tahoe
- TCP Tahoe(타호)는 초반에 느린 시작을 사용해 혼잡 윈도우 크기를 지수적으로 키운다. 혼잡이 발생했다고 판단되면 혼잡이 발생한 윈도우 크기의 절반을 ssthresh로 설정하고 혼잡 윈도우의 크기를 초기화한다.
![](https://i.imgur.com/dzsPVwh.png)
_TCP Tahoe의 예_

#### 2. TCP Reno
- TCP Reno(레노)는 TCP Tahoe와 동일하게 초반에는 느린 시작을 사용하지만, 3 Duplicate ACK와 타임아웃을 구분해 대응한다. 
- 3 Duplicate ACK가 발생하면 혼잡 윈도우 크기를 절반으로 줄이고, 줄인 혼잡 윈도우 크기를 ssthresh 값으로 설정한다. 이 부분은 빠른 회복과 동일한 방식이다. 
- 하지만 타임아웃이 발생하면 TCP Tahoe와 마찬가지로 혼잡 윈도우 크기를 1로 초기화한다. 이때 ssthresh 값은 변경하지 않는다.
![](https://i.imgur.com/Jb37QMF.png)
_TCP Reno 예_

## 오류 제어
데이터에 오류 또는 유실이 발생할 때 데이터의 신뢰성을 보장하기 위해 오류를 제어하는 방식
- 데이터에 오류 또는 유실 발생을 인지하는경우 3가지
	- 수신부에서 잘못된 데이터를 받았다는 응답인 NAK(Negative Acknowledge) 메시지를 보낸 경우
	- 3 Duplicate ACK가 발생할 때
	- 수신부로부터 ACK 메시지를 받지 못해 타임아웃이 발생할 때
### 1. 정지-대기
송신한 패킷에 대한 ACK 메시지를 일정 시간 동안 받지 못해 타임아웃이 발생하면 해당 패킷을 다시 보내는 방식
(흐름 제어에서 나왔던 방식)
![](https://i.imgur.com/kEbw4Vf.png)
_정지-대기 예_
- 데이터를 1개만 보내고 메시지를 기다려야 하기 때문에 ARQ 방식이 사용된다.
- ARQ는 재전송 요청을 의미(Automatic Repeat Request)

## 2. Go-Back-N ARQ
송신부에서 연속적으로 데이터를 보냈을 때 누락된 데이터가 있으면 송신부에서 해당 데이터부터 재전송하는 방식
 ![](https://i.imgur.com/nml9ioC.png)
_Go-Back-N ARQ 예_

## Selective-Repeat ARQ
누락된 데이터가 있으면 수신부에서 해당 데이터만 재전송을 요청하는 방식
 ![](https://i.imgur.com/cyq8iwJ.png)
_Selective-Repeat ARQ 예_
- 특정 패킷만을 재전송한다는 점은 효율적으로 보이지만, 받은 패킷을 재정렬하는 로직이 추가로 필요하다.