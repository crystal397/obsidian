# 1-3 스케줄링
- 멀티 프로세스 환경에서는 여러 프로세스가 모두 실행되어야 하지만, CPU의 자원은 한정적이다. 그래서 스케줄링을 통해 모든 프로세스를 공평하게 실행해, 한정된 자원을 효율적으로 활용하는 것이 OS의 주된 목적이다. OS에서 스케줄링은 빠질 수 없는 개념이기 때문에, 목적, 단계와 각종 용어들을 숙지해야 한다.
---
- ## 스케줄링의 목적 ★
	- 스케줄링의 주된 목적은 **멀티 프로세스 환경에서 모든 프로세스를 공평하게 실행하는 것**이다.
	- 5가지 목적
		- **공평성**: 모든 프로세스가 공평하게 실행되어야 한다. 특정 프로세스가 실행되지 않는 경우가 없도록 스케줄링해야 한다.
		- **효율성**: 자원을 효율적으로 사용해 자원이 사용되지 않는 시간이 없도록 스케줄링해야 한다.
		- **안정성**: 우선순위를 고려해 높은 우선순위의 프로세스를 먼저 처리하도록 스케줄링해야 한다.
		- **반응 시간 보장**: 프로세스가 오랜 시간 응답이 없으면 사용자는 시스템이 멈춘 것으로 보기 때문에, 일정 시간 내에 응답할 수 있도록 스케줄링해야 한다.
		- **무한 연기 방지**: 특정 프로세스에 대한 처리가 무한히 연기되지 않도록 스케줄링해야 한다. 
---
- ## 스케줄링의 단계 ★★★
	- 스케줄링은 장기 스케줄링, 중기 스케줄링, 단기 스케줄링으로 나뉜다.
	![400](https://i.imgur.com/tFaFh5Q.png)  _스케줄링의 단계_
	- **장기 스케줄링(long-term scheduling)**
		- 준비 큐에 어떤 프로세스를 넣을지 결정해 메모리에 올라가는 프로세스 수를 조절한다.
		- **잡 스케줄링(job scheduling)** 또는 **승인 스케줄링(admission scheduling)** 이라고도 한다.
		- 현대 운영체제에서는 시분할 시스템을 사용하기 때문에 대부분 사용하지 않는다.
	- **중기 스케줄링(mid-term scheduling)**
		- 메모리에 로드된 프로세스 수를 동적으로 조절한다.
		- 메모리에 프로세스가 많이 로드되면 **스왑 아웃(swap out)** 해서 일부 프로세스를 통째로 저장한다.
		- 스왑 아웃된 프로세스는 **중단 상태(suspended)** 가 된다.
		- 중단 상태는 준비 상태에서 스왑 아웃된 '중단된 준비 상태'와 대기 상태에서 스왑 아웃된 '중단된 대기 상태'로 구분된다.
	- **단기 스케줄링(short-term scheduling)**
		- 준비 큐에 있는 대기 상태 프로세스 중 어떤 프로세스를 다음으로 실행할지 스케줄링 알고리즘으로 결정한다.
		- 즉, 어떤 프로세스를 디스패치할지 결정하는데, 이를 **CPU 스케줄링**이라고도 한다. 
		![400](https://i.imgur.com/D9vcIkt.png)  _스케줄러 관점에서 스케줄링_
	- ## 스케줄링 실행도 설명
		1. 스케줄러가 준비 큐에 있는 프로세스(P1, P2, P3, P4) 중 하나를 선택해 CPU에 디스패치(프로세스 상태 용어 참고)한다. 이때 스케줄링 알고리즘을 이용한다.
		2. CPU에서 프로세스를 실행한다. 이때 프로세스는 실행상태다.
			A. 프로세스 수행이 완료되면 프로세스를 종료한다.
			B. 일정 시간을 초과하면 인터럽트가 발생해 프로세스가 준비 큐로 들어가고 준비 상태가 된다.
			C. 입출력 요청이 들어오면 인터럽트가 발생한다. 이때 프로세스는 대기 큐로 들어가서 대기 상태가 된다. 입출력이 완료되면 프로세스는 준비 큐로 들어간다.
		3. fork()가 호출되면 자식 프로세스가 생성되고, 자식 프로세스는 준비 큐로 들어간다.
	- #### 프로세스 상태(Process state) 용어
		- **생성(create)** : 프로세스가 생성되는 중이다.
		- **실행(running)** : 프로세스가 프로세서를 차지하여 명령어들이 실행되고 있다.
		- **준비(ready)** : 프로세스가 프로세서를 사용하고 있지는 않지만 언제든지 사용할 수 있는 상태로, CPU가 할당되기를 기다리고 있다.
		- **대기(waiting)** : 프로세스가 입출력 완료, 시그널 수신 등 어떤 사건을 기다리고 있는 상태를 말한다.
		- **종료(terminated)** : 프로세스의 실행이 종료되었다.
		아래는 프로세스의 상태전이이다.  
		- **디스패치(Dispatch)** : 프로세스가 준비 상태에서 실행 상태로 전환되었다.
		- **타이머 런아웃(Timer Runout)** : 프로세스가 실행 상태에서 준비상태로 전환되었다. 일반적으로 선점 프로세스에서 발생한다.
		- **블록(Block)** : 프로세스가 자원 부족, I/O 입출력대기, [인터럽트](https://namu.wiki/w/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8 "인터럽트") 등 다른 사유에 의해 실행 상태에서 대기 상태로 전환되었다.(인터럽트: CPU가 특정 기능을 수행하는 도중에 급하게 다른 일을 처리하고자 할 때 사용할 수 있는 기능)
		- **활성화(Wake-up)** : 프로세스가 부족한 자원을 재할당 받았다는 등의 사유로 대기 상태에서 준비 상태로 전환되었다.
	- #### 하나 더 알기
		![400](https://i.imgur.com/23uAqMH.png)  _스왑 아웃과 스왑 인_
		- **스왑 아웃(swap out)**: 프로세스가 실행되려면 메모리에 로드되어야 한다. 그런데 메모리 공간보다 많은 프로세스가 로드되는 경우가 있을 수 있다. 이럴 때 중기 스케줄러가 이벤트 발생을 기다리고 있는 프로세스를 통째로 저장 공간(SSD와 같은 영역)으로 옮겨 저장하는 것을 스왑 아웃이라고 한다.
		- **스왑 인(swap in)**: 스왑 아웃한 프로세스에서 이벤트 요청이 오면 해당 프로세스를 통째로 다시 메모리에 로드하는 것을 스왑 인이라고 한다.
		- **스와핑(swapping)**: 스왑 아웃과 스왑 인처럼 프로세스를 통째로 메모리 영역과 저장 공간으로 옮기는 것을 스와핑이라고 한다. 스와핑하면 메모리 공간보다 많은 프로세스를 실행할 수 있다는 장점이 있다.
---
- ## 스케줄링 알고리즘 ★★★
	- ==CPU 스케줄러(단기 스케줄러)가 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬지 결정하는 데 사용==한다.
	- 스케줄링 알고리즘은 스케줄링의 목적을 달성하기 위해 다음과 같은 기준으로 평가한다. 
	- 하지만 이를 모두 만족하기는 어려우므로, 어떤 기준을 더 중요하게 여길지 판단해야 한다.
		- **CPU 사용률**: CPU를 놀리지 않고 사용하는지 판단
		- **처리량**: 단위 시간(time unit)당 실행한 프로세스 수
		- **응답 시간**: 프로세스에 요청이 발생했을 때 응답까지 걸리는 시간
		- **반환 시간**: 프로세스가 로드된 이후부터 종료될 때까지 걸리는 시간
		- **대기 시간**: 프로세스가 대기 큐에서 대기하는 시간의 총합
- ### 비선점형 스케줄링
	- 비선점형 스케줄링(non-preemptive scheduling)은 **실행 중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없음을 의미**한다.
	- 해당 알고리즘으로는 FCFS(First Come First Served) 스케줄링, SJF(Shortest Job First) 스케줄링, HRRN(Highest Response Ration Next) 스케줄링이 있다.
	- **FCFS 스케줄링**: 준비 큐에 먼저 들어온 프로세스가 우선순위를 갖는 알고리즘이다. 준비 큐에 먼저 들어온 프로세스(first come)를 먼저 실행(first served)한다.
	- **SJF 스케줄링**: 실행 시간이 짧은 프로세스가 우선순위를 갖는 알고리즘으로, SJN(Shortest Job Next) 스케줄링이라고도 한다. 준비 큐에 있는 프로세스 중 CPU를 점유하는 실행 시간이 가장 짧은 프로세스(shortest job)부터 실행한다. 평균 대기 시간이 가장 짧지만, 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에 밀려 기아 상태가 될 수 있다. 
	- #### 용어 사전
		- 기아 상태(starvation): 프로세스마다 우선순위(priority)가 있는데, 우선순위가 높은 프로세스만 수행되어 우선순위가 낮은 특정 프로세스는 계속 실행되지 못하는 것을 의미한다.
---
- ## 선점형 스케줄링
	- 선점형 스케줄링(preemptive scheduling)은 스케줄러가 **실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있음을 의미**한다.
	- 해당 알고리즘으로는 RR 스케줄링, SRTF(Shortest Remaining Time First) 스케줄링, 멀티 레벨(multi level) 스케줄링이 있다.
	- **RR 스케줄링**
		- 비선점형 스케줄링과 달리 프로세스 간 우선순위가 없다. 모든 프로세스를 순서대로 일정 시간동안 실행하며, 일정 시간을 초과하면 다른 프로세스를 실행한다.
		- 여기서 일정 시간은 '시간 단위'를 의미하며 타임 퀀텀(time quantum) 또는 타임 슬라이스(time slice)라고도 한다.
		- 일반적으로 시간 단위는 10~100밀리초다.
		- 콘텍스트 스위칭(프로세스/스레드 교체)이 빈번하게 일어나서 오버헤드가 크다는 단점이 있지만, 모든 프로세스가 반복 수행되어 응답 속도가 빠르다는 장점도 있다.
			- **응답 속도 빠르지만 오버헤드(추가 자원 사용)가 크다!**
	- **SRTF 스케줄링**
		- 준비 큐에서 대기 시간이 가장 짧게 남은 프로세스(shortest remaining time)를 우선 수행(first)하는 알고리즘이다.
		- 한 프로세스가 실행 중일 때 실행 시간이 더 짧은 프로세스가 준비 큐에 들어오면 실행 시간이 더 짧은 프로세스가 CPU를 차지하기 된다.
		- 평균 대기 시간이 짧다는 장점이 있지만, 수행 시간이 긴 프로세스는 기아상태가 되기 쉽다.
			- **평균적으로는 대기 시간 짧지만 우선순위 낮은 프로세스는 기아 상태가 되기 쉽다!**
	- 멀티 레벨 스케줄링
		- 준비 큐를 목적에 따라 여러 개로 분리해 사용하는 알고리즘이다.
		- 분리한 큐는 각각 우선순위가 있고, 각자 다른 스케줄링 알고리즘을 적용할 수 있다.
		- 여러 개의 큐는 foreground 큐와 background 큐로 나뉜다. foreground 큐에는 응답 속도가 중요한 프로세스가 들어가고, background 큐에는 응답 속도보다 성능을 중요시하는 프로세스가 들어간다.
	- #### 용어 사전
		- 콘텍스트 스위칭: CPU/코어에서 실행 중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것
		- 오버헤드: 어떤 명령어를 처리하는데 소비되는 간접적, 추가적인 컴퓨터 자원을 의미한다. 
- ## 스케줄링 예제	
	![400](https://i.imgur.com/AQ1vVkN.png)  _준비 큐에 담긴 프로세스 예_
	- ### 1. FCFS(First Come First Served) 스케줄링
		![400](https://i.imgur.com/lGznMnD.png)  _FCFS 스케줄링 실행 순서_
		![350](https://i.imgur.com/dntIi8N.png)  _FCFS 스케줄링 평균 대기 시간 계산_
		- 평균 대기 시간은 각 프로세스의 대기 시간을 합한 뒤 프로세스의 수로 나눈 것과 같다.
		- 따라서 FCFS 스케줄링 평균 대기 시간은 290이 된다.
	- ### 2. SJF(Shortest Job First) 스케줄링
		![400](https://i.imgur.com/uczTcv0.png)  _SJF 스케줄링 실행 순서_
		![350](https://i.imgur.com/H47xqq3.png)  _SJF 스케줄링 평균 대기 시간 계산_
		- 같은 방법으로 계산하면 SJF 스케줄링에서 평균 대기 시간은 218로, FCFS 스케줄링 알고리즘보다 짧은 것을 알 수 있다.
	- ### 3. RR(Round Robin) 스케줄링	
		![400](https://i.imgur.com/IbD2rre.png)  _RR 스케줄링 실행 순서_
		- RR 스케줄링에서 어떤 프로세스에서 응답 요청이 들어왔을 때 기다리는 최대 시간은 (전체 프로세스 수) - 1에 (시간 단위)를 곱한 값이다.
		- 예시에서는 (5 - 1) x 50 = 200밀리초 안에 응답할 수 있다. 응답 속도가 다른 스케줄링보다 빠르지만, 콘텍스트 스위칭이 빈번하게 일어나므로 시간 단위를 적절하게 설정해야 한다.
	- ### 4. SRTF(Shortest Remaining Time First) 스케줄링
		![400](https://i.imgur.com/dMvErBL.png)  _SRTF 스케줄링 실행 순서_
		![350](https://i.imgur.com/fOm4OOD.png)  _SRTF 스케줄링 평균 대기 시간 계산_
		- P1과 같이 프로세스가 중간에 중단된 경우에는 수행 완료까지의 대기 시간을 합하면 된다.
		- SRTF 스케줄링이 다른 스케줄링 알고리즘보다 평균 대기 시간이 짧은 것을 알 수 있다.
		- 하지만 P3가 P4보다 준비 큐에 빨리 들어왔어도 실행 시간이 길어서 마지막 순서로 밀렸듯이, 실행 시간이 긴 프로세스는 기아 상태가 되기 쉽다.
		- 마지막으로 멀티 레벨 스케줄링은 그림처럼 준비 큐가 목적에 맞춰 여러 큐로 나뉘어 있다.
		- 프로세스가 들어오면 해당 프로세스의 우선 순위에 맞는 큐에 들어가서 대기하게 된다.
		![400](https://i.imgur.com/Fo7N6OI.png)  _멀티 레벨 스케줄링_

---
스케줄링
스케줄링의 목적 : 멀티 프로세스 환경에서 모든 프로세스를 공평하게 실행하는 것
- 공평성: 특정 프로세스가 실행되지 않는 경우가 없게 해야 함
- 효율성: 자원이 사용되지 않는 시간이 없도록 해야 함
- 안정성: 우선순위를 고려해 실행시켜야 함
- 반응 시간 보장: 일정 시간 내에 응답을 보장해야 함
- 무한 연기 방지: 무한히 연기되지 않게 해야 함

![](https://i.imgur.com/cHbrJTL.png)

스케줄링의 단계:
- 장기 스케줄링: 준비 큐에 어떤 프로세스를 넣을 지 결정하는 단계
	- =잡 스케줄링, 승인(admission) 스케줄링
	- 현대 운영체제에서는 시분할 시스템을 사용하기 때문에 대부분 사용하지 않음

- 중기 스케줄링: 메모리에 로드된 프로세스 수를 동적으로 조절하는 단계
	- 메모리에 너무 많이 로드될 시: 스왑 아웃 (=중단 상태)
	- 스왑 아웃은 준비와 대기 단계에서 이루어지므로 '중단된 00 상태'로 구분
	- 스왑 아웃: 프로세스를 통째로 저장 공간으로 옮겨 저장하는 것 <-> 스왑 인
	- 스와핑: 스왑 아웃 & 스왑 인

- 단기 스케줄링
	- =CPU 스케줄링
	- 준비 큐에 있는 대기 상태 프로세스중 다음 실행할 프로세스를 스케줄링 알고리즘으로 결정 (=디스패치)
![](https://i.imgur.com/ovvGwUA.png)
---
- ## 스케줄링 알고리즘★★★
	- ==CPU 스케줄러(단기 스케줄러)가 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬지 결정하는 데 사용.==
	- 스케줄링 평가 기준
		- CPU 사용률 : CPU를 놀리지 않고 사용하는지 판단
		- 처리량 : 단위 시간(time unit)당 실행한 프로세스 수
		- 응답 시간 : 프로세스에 요청이 발생했을 때 응답까지 걸리는 시간
		- 반환시간 : 프로세스가 로드된 이후부터 종료될 때까지 걸리는 시간
		- 대기시간 : 프로세스가 대기 큐에서 대기하는 시간의 총합
	- ### 비선점형 스케줄링 (non-preemptive scheduling)
		- ==실행 중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없음을 의미==
			- FCFS(First Come First Served) 스케줄링
				- 준비 큐에 먼저 들어온 프로세스가 우선순위
				- 준비 큐에 먼저 들어온(first come) 프로세스를 먼저 실행(first served)
			- SJF(Shortest Job First) 스케줄링
				- 실행 시간이 짧은 프로세스가 우선순위
				- SJN(Shortest Job Next) 스케줄링 이라고도 한다
				- 준비큐에 있는 프로세스중 CPU를 점유하는 실행 시간이 가장 짧은 프로세스(shortest job)부터 실행
				- 평균 대기 시간이 가장 짧지만, 실행 시간이 긴 프로세스는 **기아상태**가 될수 있다.
					- 기아 상태(starvation) : 프로세스마다 우선순위가 있다, 우선 순위가 높은 프로세스만 수행되어 **우선순위가 낮은 프로세스는 계속 실행되지 못하는것을 의미한다**.
			- HRRN(Highest Response Ratio Next) 스케줄링
	- ### 선점형 스케줄링
		- ==스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있음을 의미==
			- RR(Round Robin) 스케줄링
				- 비선점형 스케줄링과 달리 프로세스간 우선순위가 없다.
				- 모든 프로세스를 순서대로 일정 시간 동안 실행
				- 일정 시간 초과시 다른 프로세스를 실행
				- 일정 시간은 '시간 단위'를 의미하며 타임 퀀텀(time quantum)또는 타임 슬라이스(time slice)라고도 한다
				- 일반적으로 시간 단위는 10~100ms
				- 단점 : 콘텍스트 스위칭이 빈번하게 일어나서 오버헤드가 크다
				- 장점 : 모든 프로세스가 반복 수행되어 응답 속도가 빠르다
			- SRTF(Shortest Remaining Time First) 스케줄링
				- 준비 큐에서 ~~대기 시간~~ 실행 시간이 가장 짧게 남은 프로세스 우선 수행
				- 한 프로세스가 실행 중일 때 ==실행 시간이 더 짧은 프로세스가 준비큐에 들어오면 실행 시간이 더 짧은 프로세스가 CPU 차지==
				- 장점 : **평균 대기 시간이 짧다**
				- 수행 시간이 긴 프로세스는 **기아상태**가 되기 쉽다
			- 멀티 레벨(multi level) 스케줄링
				- 준비 큐를 목적에 따라 여러 개로 분리해 사용하는 알고리즘
				- 분리한 큐는 각각 우선순위가 있고 각자 다른 스케줄링 알고리즘을 적용
				- 여러 개의 큐는 foreground 큐와 background 큐로 나뉜다
				- foreground 큐에는 **응답 속도가 중요한 프로세스**가 들어간다
				- background 큐에는 응답 속도보다 **성능을 중요시하는 프로세스**가 들어간다