# 4.1. 복잡도

- 자료구조나 알고리즘에서 빠지지 않는 개념 (중요)
- 작성한 알고리즘이 시간적, 공간적 측면에서 효율적인지 판단할 수 있는 기준이 됨
- 현업에서 개발 시 시간적, 공간적 제약이 있어서 효율적인 알고리즘을 짜는 능력 필요

### 4.1.1. 복잡도와 빅오 표기법 ⭐️

- 알고리즘이 얼마나 효율적인지 정량화하는 데 [시간 복잡도]와 [공간 복잡도]라는 개념을 사용
- **시간 복잡도** : 알고리즘의 실행 시간을 정량화하는 것
- **공간 복잡도** : 실행하는 데 필요한 메모리 사용량을 정량화하는 것

#### 빅오 표기법 (big-O notation)
- 알고리즘의 복잡도는 주로 빅오 표기법으로 나타냄
- 입력 값(n)에 대한 수식에서 최고차항을 기준으로 알고리즘이 수행되는 최악의 시간 복잡도를 표현
- 최고차항을 기준으로 표현하는 이유는 연산의 수가 극한에 수렴할 때 나머지 항이 복잡도에 미치는 영향은 미미하기 때문
	- 빅오 표기법은 최악의 경우를 고려하므로, 프로그램이 실행되는 과정에서 **소요되는 최악의 시간**까지 고려할 수 있음
	- “최소한 특정 시간 이상이 걸린다” 혹은 “이 정도 시간이 걸린다”를 고려하는 것보다 **“이 정도 시간까지 걸릴 수 있다”를 고려해야 그에 맞는 대응**이 가능
	
		![600](https://i.imgur.com/zEmuUqw.png)
- 대표적인 빅오 표기법 
	- 실행 속도 : O(1) < 𝑂(𝑙𝑜𝑔𝑁)  < 𝑂(𝑛) < 𝑂(𝑁𝑙𝑜𝑔𝑁)  < 𝑂(𝑛^2) < 𝑂(2^𝑛)
	- 최고차항이 커질수록 소요되는 시간이 급격히 증가됨

#### 접근적 표기법 (asymptotic notation)
- 알고리즘의 복잡도를 나타낼 때 계수, 상수항 등 중요하지 않은 항목을 무시하고 표현하는 것
- 최고차항이 알고리즘의 성능에 가장 큰 영향을 미치기 때문에, 알고리즘 수행시간 표기를 위해 불필요한 부분(계수와 상수항)을 무시함
- 점근적 표기 법 3가지
	1. 최악의 경우 : 빅오 표기법 (big-O notation)
	2. 평균의 경우 : 빅세타 표기법 (big-Θ notation)
	3. 최선의 경우 : 빅오메가 표기법 (big-Ω notation)

---

# 4.2. 선형 자료구조 (Linear data structure)

- 연속적으로 데이터가 나열되는 자료구조
- 하나의 데이터 뒤에 다른 하나의 데이터가 연결됨
- 대표적으로 배열, 리스트, 스택, 큐 등이 있음
- 기술 면접 시 특정 자료구조의 개념을 직접 묻기보다는 상황을 주고 해당 상황을 해결하는 데 적합한 자료구조가 무엇인지 묻는 방식으로 출제됨

### 4.2.1. 배열 ⭐️⭐️

- 정해진 크기만큼 데이터가 일렬로 저장되는 정적(static) 자료구조
- 요소(element) : 각 데이터를 배열의 요소라고 함
- 인덱스(index) : 데이터를 가리키는 번호
	- 일반적으로 배열의 인덱스는 0부터 (배열크기 - 1) 까지 참조 가능

### 4.2.3 스택(Stack)
- **스택의 정의**
	- 데이터를 쌓는 형태로 LIFO형식(후입선출)의 자료구조
	- push: 스택에 데이터를 삽입
		- 스택의 가장 위에 데이터를 저장

	- pop: 스택에 있는 데이터를 삭제
		- 마지막에 저장한 데이터 삭제
	- top: 마지막으로 저장한 데이터의 인덱스 기억
	- 스택 구현시 배열과 연결리스트 이용![[스크린샷 2024-06-09 오후 3.39.59.png]]
- **스택의 연산 및 시간복잡도**![[스크린샷 2024-06-09 오후 4.00.27.png]]
- **스택의 활용**
	- 스택은 주로 프로그램을 수행할 때 사용
	- Main 프로그램에서 함수 A를 호출하면 Main 프로그램 위에 함수 A가 쌓이고, 함수 A의 수행 중에 함수 B가 호출되면, 함수 A위에 함수 B가 스택처럼 쌓이게 됨. 함수 B의 실행이 완료되면 함수 A가 실행되고, 함수 A의 실행이 완료되면 주 프로그램이 실행(LIFO)



### 4.2.4 큐(Queue)
- **큐의 정의**
	- 데이터가 순차적으로 들어오는 형태
	- FIFO(선입선출)형식의 자료구조 
	- front: 큐의 맨 앞, 데이터를 삭제하면 front에서 삭제(dequeue)
	- rear: 큐의 맨 뒤, 데이터를 추가하면 rear에 삽입됨(enqueue)
	- 큐 구현시 배열과 연결리스트 이용	![[스크린샷 2024-06-09 오후 3.40.31.png]]
- **큐의 연산 및 시간복잡도**![[스크린샷 2024-06-09 오후 4.01.05.png]]

- **큐의 활용**
	- 큐는 프로세스 처리에서 사용하는 자료구조
	- 운영체제에서 프로세스가 CPU를 할당받기 전까지 대기하는 준비 큐가 있음
	- 작업 처리 시 요청 순서대로 처리하기 위해 큐를 사용
		- 컴퓨터 안에 여러 개의 프로세스가 수행 중일 때 새로운 프로세스가 수행되어야 하는 경우, 기존에 수행되던 프로세스 중에서 가장 먼저 메모리에 올라온 프로세스가 아웃(실행)
		- 이후 새로운 프로세스를 메모리에 올리게 되는데, 이 경우 운영체제는 현재 수행 중인 프로세스를 큐의 형태로 관리
		- Windows 운영체제를 사용하는 컴퓨터에서 수행 중인 프로그램에 이벤트 (버튼 누르기, 윈도우 크기 조정, 메뉴 선택하기 등)가 발생하면 발생한 이벤트가 큐에 저장되고, 수행중인 프로그램이 큐에 저장된 것을 앞에서부터 읽어 와서 처리(FIFO)
- **배열 큐에서의 연산**
	- 큐를 배열로 구현하면 rear의 인덱스를 이용해 큐가 가득 찼는지 확인 가능
	- 인큐 또는 디큐 수행시 front나 rear만 수정하면 되어 시간복잡도에서 유리![[스크린샷 2024-06-09 오후 4.17.59.png]]
	
	- 한계 
		- 데이터 삽입 연산으로 큐를 꽉 채운 뒤, 1개만 남기고 삭제 연산을 수행하면 rear의 인덱스를 보고 큐에 데이터가 가득 찼다고 생각할 수 있음
		- 인큐나 디큐를 수행할 때, 데이터의 위치를 옮기면 되지만 시간 복잡도가 늘어나는 문제 발생![[스크린샷 2024-06-09 오후 4.19.40.png]]
	
- **순환 큐(circular queue, 원형 큐)**
	- 삽입 연산을 할 때 배열의 앞부분에 데이터 삽입![[스크린샷 2024-06-09 오후 4.22.17.png]]
	- 배열의 시작과 끝이 구분되지 않아 데이터 삽입과 삭제를 유연하게 수행 가능 ![[스크린샷 2024-06-09 오후 4.23.14.png]]
- **덱(deque, double-ended queue)**
	- 양쪽 끝에서 데이터의 삽입과 삭제가 모두 가능한 자료구조
	- 큐와 스택을 합친 형태![[스크린샷 2024-06-09 오후 4.24.27.png]]

---
# 4.3.  비선형 자료구조

비선형 자료구조(non-linear data structure)는 1:N 또는 N:N 구조로 데이터가 나열되는 자료구조입니다. 이는 계층적 구조를 나타내기 편리하며, 원하는 데이터를 빠르게 탐색할 수 있는 장점이 있습니다. 대표적인 비선형 자료구조로는 그래프가 있습니다.

### 4.3.1. 그래프 ⭐️⭐️⭐️

그래프(graph)는 정점(vertex)과 정점을 잇는 간선(edge)으로 구성된 자료구조입니다. 정점은 노드(node)라고도 하며, 일반적으로 그래프는 G = (V, E)로 표현됩니다.
![[Pasted image 20240610222341.png]]

#### 용어 설명
- **인접(adjacent)**: 두 정점이 간선으로 연결되어 있으면 인접하다고 합니다.
- **차수(degree)**: 정점에 연결된 간선의 수를 나타냅니다.
- **진입 차수(in-degree)**: 해당 정점으로 향하는 간선의 수를 의미합니다.
- **진출 차수(out-degree)**: 해당 정점에서 나가는 간선의 수를 의미합니다.
- **경로(path)**: 한 정점에서 다른 정점으로 이어지는 정점들의 리스트입니다.
- **경로 길이(path length)**: 경로를 구성하는 간선의 수입니다.
- **단순 경로(simple path)**: 모두 다른 정점으로 구성된 경로입니다.
- **사이클(cycle)**: 한 정점에서 시작해 같은 정점으로 돌아올 수 있는 경로입니다.

#### 그래프의 종류
1. **무방향 그래프(undirected graph)**: 간선에 방향성이 없는 그래프입니다. 두 정점이 연결되어 있을 때 순서가 없습니다.
![[Pasted image 20240610222421.png]]
2. **방향 그래프(directed graph)**: 간선에 방향성이 있는 그래프입니다. 두 정점이 연결되어 있을 때 방향이 존재합니다.
![[Pasted image 20240610222502.png]]

##### 하나 더 알기 - 기타 그래프 종류
- **부분 그래프(sub graph)**: 기존 그래프에서 일부 정점 또는 간선을 제외한 그래프입니다.
- **가중치 그래프(weighted graph)**: 간선에 비용이나 가중치가 할당된 그래프입니다.
- **완전 그래프(complete graph)**: 모든 정점이 서로 연결된 그래프입니다.
- **유향 비순환 그래프(DAG, Directed Acyclic Graph)**: 방향 그래프이면서 사이클이 없는 그래프입니다.

#### 경로 탐색

그래프 탐색 문제는 시작 정점에서 모든 정점을 탐색하는 경로를 찾는 문제입니다. 주요 탐색 방법으로 BFS와 DFS가 있습니다.
1. **너비 우선 탐색(BFS, Breadth-First Search)**
- 가까운 정점부터 탐색하는 방식입니다. 큐를 사용하여 구현하며, 비가중치 그래프에서 최단 거리를 찾는 데 유용합니다.
2. **깊이 우선 탐색(DFS, Depth-First Search)**
- 최대 깊이 정점까지 탐색한 후, 역순으로 재방문하면서 탐색 가능한 정점을 찾는 방식입니다. 스택이나 재귀 호출을 통해 구현하며, 경로를 찾는 데 유용합니다.


