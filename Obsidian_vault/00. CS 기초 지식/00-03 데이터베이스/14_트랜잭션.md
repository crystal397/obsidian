# 트랜잭션 - 중요도 🥈

: **트랜잭션(transaction)은 데이터베이스의 상태를 바꾸기 위해 수행하는 작업의 단위, 또는 일련의 연산**을 의미한다. 다음 ACID는 데이터베이스 트랜잭션의 4가지 특성에서 첫 글자를 딴 용어이다.

  

## ACID

  

- **원자성(Atomicity):** 트랜잭션이 데이터베이스에 완전히 반영되거나 아예 실행되지 않아야 한다.
	- 원자성의 사전적 정의: '어떤 것이 더 이상 쪼개질 수 없는 성질'
	
	- 티켓 예약 시스템을 원자성의 예로 들 수 있다. 티켓은 지불과 예약이 동시에 되거나, 아니면 모두 되지 않아야 한다. 지불은 되었으나 예매가 되지 않거나, 지불이 되지 않았으나 예매가 되는 경우는 허용되지 않는다.
	
	- 즉, **어떤 작업이 실행될 때 완전히 진행되고 종료되거나, 그럴 수 없는 경우에는 실행 자체를 하지 않아야 한다.**

  

- **일관성(Consistency):** 트랜잭션 수행이 완료된 데이터베이스는 트랜잭션 이전과 이후의 상태에 일관성이 있어야 한다.
	- '모든 고객은 반드시 이름을 가지고 있어야 한다'는 데이터베이스의 규칙을 예로 들 수 있다. '이름 없는 새로운 고객을 추가하는 쿼리' 또는 '기존 고객의 이름을 삭제하는 쿼리'의 트랜잭션은 '이름을 가지고 있어야 한다'는 데이터베이스의 제약을 위반하기 때문에, 데이터베이스는 일관되지 않는 상태를 가지게 된다.
	
	- 다시 말해, **트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다**는 말이다.

  

- **독립성(Isolation)**: 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들 수 없다.
	- 계좌 송금 데이터베이스를 예로 들 수 있다. A 계좌에 10,000원이 있다고 가정해보자. B 계좌로 6,000원을, C 계좌로 6,000원을 동시에 계좌이체 하려면 각각의 송금 작업을 연속으로 실행한 것과 동일한 결과가 나타나야 한다. 잔고가 -2,000원이 되는 마이너스 통장이 아니기 때문이다.
	
	- 격리성을 준수하는 트랜잭션은 철저히 독립적되어야하기 때문에 다른 트랜잭션의 작업 내용을 알 수 없다.
	
	- 결과적으로 **트랜잭션이 동시에 실행될 때와 연속으로 실행될 때의 데이터베이스 상태가 동일해야 한다**는 것이다.

  

- **영속성(Durability):** 완료한 트랜잭션의 결과가 데이터베이스에 영구적으로 반영된다.
	- 예를 들어, 은행에서 계좌이체를 완료한 뒤에 은행 데이터베이스에 오류가 발생해 종료되더라도 계좌이체 내역은 로그가 남아야 한다.
	
	- 마찬가지로 계좌이체 로그를 기록하기 전에 시스템 오류로 종료된다면, 이체 내역은 실패로 기록되고 각 계좌들은 이전 상태로 돌아가야 한다.
	
	- 즉, 트랜잭션이 성공적으로 수행되었다면 해당 트랜잭션에 대한 로그가 남아야 하는 성질을 설명하는 것이다. Runtime error나 System error가 발생하더라도 기록은 영구적이어야 한다는 뜻이다.

  
  

==원자성 때문에 트랜잭션은 완전히 반영되거나 아예 실행되지 않아야 한다.==

  

따라서 트랜잭션을 제어하기 위해 TCL(Transaction Control Language)이라는 명령어를 사용한다.

  
  

## TCL의 종류
- COMMIT: 트랜잭션이 정상적으로 종료되어 데이터베이스에 변경 사항을 반영하는 명령어다.

- ROLLBACK: 트랜잭션이 비정상적으로 종료되어 트랜잭션이 수행한 변경 사항을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어다.

- SAVEPOINT: 트랜잭션에서 특정 지점을 지정하는 명령어로, ROLLBACK과 함께 사용하면 해당 지점까지 되돌릴 수 있다.

  

---

  

## 하나 더 알기

: 트랜잭션이 수행되는 단계와 각 단계에서의 상태는 다음과 같다.

  

![](https://i.imgur.com/7pWUb5R.png)

(그림) 트랜잭션 수행 단계와 상태

  

- **활성화:** 트랜잭션이 시작되어 처리 중인 상태

- **부분적 완료:** 트랜잭션의 마지막 연산까지 처리가 완료되었지만 데이터베이스에 트랜잭션 수행 결과가 반영되지 않은 상태

- **완료:** 트랜잭션의 연산 처리가 완료되고 데이터베이스에 결과가 반영된 상태

- **실패:** 트랜잭션 처리 중 오류가 발생해 트랜잭션이 중단된 상태

- **철회:** 트랜잭션이 중단되어 ROLLBACK을 수행해 데이터베이스를 이전으로 되돌린 상태

  

## 깊게 알기: 트랜잭션 격리

여러 트랜잭션이 서로 영향을 미치지 않고 실행될 수 있는 단계를 **트랜잭션 격리 수준(transaction isolation level)** 이라고 한다. 이는 한 트랜잭션이 다른 트랜잭션 작업의 조회 가능 여부를 결정한다. 트랜잭션 격리 수준은 다음과 같이 4단계로 나뉜다.

![](https://i.imgur.com/6aczckk.png)

(그림) 트랜잭션 격리 수준

  

- **Read Uncommited:** 트랜잭션의 COMMIT 여부와 상관없이 다른 트랜잭션이 데이터를 조회할 수 있다. 한 번에 여러 트랜잭션을 처리할 수 있는 동시성은 높지만, 데이터의 일관성을 유지하기 어렵다.

- **Read Commited:** 트랜잭션이 COMMIT된 데이터만 다른 트랜잭션이 조회할 수 있다.

- **Repeatable Read:** 트랜잭션이 읽은 데이터를 다른 트랜잭션이 갱신하거나 삭제할 수 없다.

- **Serializable:** 트랜잭션이 읽은 데이터를 다른 트랜잭션이 갱신, 삭제, 삽입할 수 없다.

  

동시성이 높아지면 여러 트랜잭션이 동시에 처리되고 데이터의 일관성에 문제가 발생할 확률도 높아진다.

반면에 고립성을 높이면 하나의 트랜잭션이 처리 중일 때 다른 트랜잭션의 접근이 제한되어 효율이 낮아진다.

따라서 상황에 따라 데이터의 일관성을 유지하면서 트랜잭션을 효율적으로 처리할 수 있어야 한다.

  
  

---

  

## 락(Lock)

**락(lock)은 트랜잭션이 처리되는 순서를 보장하기 위한 방법**이다. 운영체제에서 데이터 동기화를 위해 임계 영역에 대한 접근을 제한하는 상호배제 기법과 유사하다. 데이터의 무결성을 유지하기 위한 락이 여러 종류가 있는데, 대표적인 락은 다음과 같다.

- **공유 락(shared lock):** 데이터를 읽는 락으로, 읽기 락(read lock)이라고도 한다. 데이터를 읽는 연산이기 때문에 데이터의 일관성에 영향을 주지 않는다. 따라서 데이터에 여러 공유 락이 동시에 접근할 수 있다.

- **베타 락(exclusive lock):** 데이터를 수정하는 락으로 쓰기 락(write lock)이라고도 한다. 데이터의 일관성을 유지하기 위해서, 특정 데이터에 하나의 베타 락이 접근 중일 때 다른 베타 락이 접근할 수 없다.

  

데이터베이스의 트랜잭션도 프로세스처럼 교착 상태(deadlock)에 빠질 수 있다. 이는 한 트랜잭션이 자신의 처리 중인 데이터에 대해 락을 가진 상태에서, 다른 트랜잭션이 처리 중인 데이터에 락을 요청해 ==무한 대기 상태에 빠진 현상==을 의미한다. 즉, 특정 데이터의 락을 가지고 있는 트랜잭션이 다른 데이터의 락을 추가로 요청하며 발생하는 현상이다.

  

### 트랜잭션 교착 상태 해결 방법

  

1. **예방 기법**

	- 트랜잭션 처리가 시작되기 전에 필요한 데이터에 대해 미리 락을 얻는 방식이다.

  

2. **회피 기법**
	- 트랜잭션이 들어온 순서에 따라 교착 상태를 회피하는 방식이다.
	
	- **wait-die:** 데이터의 락을 요청하려는 트랜잭션이 해당 데이터에 대해 이미 락을 갖고 있는 트랜잭션보다 오래되었다면 락을 얻을 때까지 기다린다. 반면, 락을 갖고 있는 트랜잭션보다 최신이라면 락 획득을 포기한다.
	
	- **wound-wait:** 데이터의 락을 요청하려는 트랜잭션이 해당 데이터에 대해 이미 락을 갖고 있는 트랜잭션보다 오래되었다면 락을 빼앗는다. 반면, 락을 갖고 있는 트랜잭션보다 최신이라면 락 획득을 기다린다.

  

---

  

## 이상(anomaly)

이상(anomaly)은 ==트랜잭션을 처리하는 중에 속성 간 종속이나 데이터 중복으로 발생하는 문제==를 말한다. 여기에는 3가지가 있다.

  

- **삽입 이상(insertion anomaly):** 데이터 삽입 시 의도치 않은 다른 데이터도 삽입된다.

- **갱신 이상(update anomaly):** 데이터 갱신 시 일부 튜플만 갱신되어 데이터 모순이 발생한다.

- **삭제 이상(deletion anomaly):** 데이터 삭제 시 의도하지 않은 데이터도 삭제된다.

  
  

---

  

## 정규화

정규화(normalization)는 ==데이터베이스의 이상 현상을 해결하기 위해 테이블을 분해하는 것==이다. 하지만 테이블을 분해하느라 연산 시간이 증가한다는 단점이 있다. 그렇기 때문에 테이블이라고 무조건 분해하는 것이 아니라, 상황에 따라 적절하게 정규화를 진행시켜야 한다. 이렇게 함으로써 이상 현상도 해결하면서 연산 속도 또한 보장할 수 있다.

  

이렇게 정규화한 결과를 **정규형(normal form)** 이라고 하며, 테이블을 분해하는 정도에 따라서 단계를 다음과 같이 나눌 수 있다(예시는 데이터베이스 내 데이터의 수정을 고려하지 않는다는 것을 전제로 작성되었다.).

  
  

![](https://i.imgur.com/WbngmVM.png)

(그림) 정규화 단계

  

### 제 1 정규형

**제 1 정규형(1NF, First Normal Form)** 은 테이블의 ==모든 속성 값이 더 이상 분해될 수 없는 값, 즉 원자값으로 구성==되어야 한다. 예를 들어, 다음 그림을 보면 왼쪽 테이블에 (롯데, (칸쵸, 빼뺴로))와 같이 '과자 이름' 속성에 속성 값이 2개 존재한다. (오리온, (꼬북칩, 다이제))도 마찬가지로 속성 값이 2개이므로 원자 값이 되도록 테이블을 분해하는 제 1 정규화를 수행하면 속성 값 2개가 각각 튜플로 나눠지게 된다. 그러면 오른쪽에 있는 제 1 정규형 테이블을 만들 수 있다.

  
  

![](https://i.imgur.com/3dbRd5Z.png)

(그림) 제 1 정규형의 예

  

### 제 2 정규형

제 2 정규형(2NF, Second Normal Form)은 제 1 정규형에 속하는 테이블에서 ==부분적 함수 종속을 제거==해 완전 함수 종속을 만족해야 한다. 함수 종속성은 테이블에서 속성 간의 종속 관계를 의미한다.

  
  

![](https://i.imgur.com/ozX783Z.png)

(그림) 함수 종속

  

예를 들어, X 속성이 Y 속성을 결정하면 Y 속성은 X 속성에 함수 종속된다고 한다. 그리고 X를 결정자, Y를 종속자라고 한다.

  

**완전 함수 종속**은 X 속성이 Y 속성을 결정하지만, X 속성의 진부분집합(자기 자신을 제외한 부분집합)이 Y 속성을 결정하지 않는 경우를 말한다.

  

따라서 **부분적 함수 종속**은 기본 키의 부분 집합이 결정자가 될 수 있음을 의미한다. 즉, ==기본 키의 진부분집합이 결정자가 될 수 없도록 테이블을 분해해야 완전 함수 종속을 만족한다==.

  

예를 들어, 제조사에 따라 과자의 판매처가 정해진다고 가정해 보자. 제조사가 롯데인 경우 롯데마트에서만 판매하고, 그 외 제조사 제품은 E마트에서만 판매한다. 다음 테이블에서 기본 키는 '제조사'와 '과자 이름' 속성이다. 가격 속성은 제조사와 과자 이름으로 정해지지만, 판매처는 제조사로만 정해진다. 즉, 기본 키의 부분 집합인 제조사가 판매처를 결정하는 결정자가 된다. 따라서 이를 제 2 정규화하면 다음과 같다.

  
  

![](https://i.imgur.com/emMCY8F.png)

(그림) 제 2 정규형 예

  

이와 같이 판매처에 대한 테이블을 분리해 완전 함수 종속을 만족시킬 수 있다.

  

#### 용어사전

- 부분집합: 집합 A의 모든 원소가 집합 B에 포함될 때, 집합 A를 집합 B의 부분집합이라고 한다.

- 진부분집합: 집합 A가 집합 B의 부분집합이면서 집합 B와 같지 않을 때, 집합 A를 집합 B의 진부분집합이라고 한다.

  

### 제 3 정규형

**제 3 정규형(3NF, Third Normal Form**)은 제 2 정규형에 속하는 테이블에서 ==이행적 종속이 없어야 한다==. 이행적 종속은 A 속성이 B 속성을 결정하고 B 속성이 C 속성을 결정할 때, A 속성이 C 속성을 결정하는 것을 의미한다. 이런 경우 A 속성이 C 속성을 결정하는 이행적 종속을 제거해야 한다.

  

즉, A 속성이 B 속성을 결정하는 테이블과, B 속성이 C 속성을 결정하는 테이블로 분해해야 한다.

  

다음 예시에서는 고객 한 명당 과자 하나만 구매할 수 있다고 전제한다.

  
  

![](https://i.imgur.com/65O1rD8.png)

(그림) 이행적 종속이 있는 테이블 예시

  

해당 테이블에서 이행적 종속은 다음과 같다. 과자 이름은 고객이 구매한 과자로 결정된다. 과자 이름은 가격을 결정한다. 고객 한 명당 과자를 하나만 구매할 수 있으므로 고객이 가격을 정하는 것처럼 종속 관계를 갖게 된다. 이러한 경우 이상이 발생하기 쉽다.

  

예를 들어, 칸쵸의 금액이 인상되었지만 칸쵸를 구매한 일부 고객의 구매 금액만 갱신된다면 갱신 이상이 발생한다. 따라서 이행적 종속을 제거하고 정규화하면 다음과 같다.

  

![](https://i.imgur.com/hn7loiP.png)

(그림) 제 3 정규화를 적용한 결과

  

### 보이스-코드 정규형

보이스-코드 정규형(BCNF, Boyce-Codd Normal Form)은 강한 제 3 정규형이라고도 한다. 이 유형은 제 3 정규형에 속하는 ==테이블의 모든 결정자가 후보키가 되도록 테이블을 분해==해야 한다.

  

다음 그림의 예시를 보면, 학번과 과목을 기본 키로 교수 속성의 값을 결정한다. 하지만 교수는 과목 속성을 결정하는 결정자이기도 하다. 따라서 결정자가 후보 키가 아니므로 BCNF를 만족하지 못한다.

  

![](https://i.imgur.com/D5UcLCu.png)

(그림) BCNF 필요 예시

  

이 테이블에 BCNF 정규화를 진행하면 결과는 다음과 같다.

![](https://i.imgur.com/iL4yDJN.png)

(그림) BCNF 정규화 결과

  

---

  

## 하나 더 알기

  

### 제 4 정규형

제 4 정규형(4NF, Fourth Normal Form)은 제 3 정규형에 속하면서 다치 종속을 제거해야 하는 유형이다. 다치 종속이란, 테이블에서 한 속성이 여러 속성의 값을 결정하는 것을 의미한다.(多値, 많을 다 + 값 치)

  

다음 예시에서 왼쪽 테이블을 제 3 정규화까지 진행하면 오른쪽 테이블이 된다. 오른쪽 테이블에서는 학생이 전공과 취미라는 두 가지 속성을 결정하고 있다. 즉, 다치 종속이 존재한다.

![](https://i.imgur.com/t466TDe.png)

(그림) 다치 종속이 있는 테이블의 예시

  

다치 종속을 제거하려면 다음과 같이 학생이 전공을 결정하는 테이블 + 학생이 취미를 결정하는 테이블로 각각 분해한다.

  

![](https://i.imgur.com/oxopAyp.png)

(그림) 제 4 정규화 결과. 다치 종속을 제거한 정규화

  

### 제 5 정규형

제 5 정규형(5NF, Fifth Normal Form)은 제 4 정규형에 속하면서 조인 종속이 없어야 한다. 조인 종속이 없다는 것은 테이블을 분해했다가 조인할 때 테이블이 복원된다는 것을 의미한다.

  

![](https://i.imgur.com/wOPEFf9.png)

(그림) 조인 종속 관계

  

위 예시를 보면 개발자와 자격증, 개발자와 언어는 관계가 있으나 자격증과 언어는 관계가 없다. 연관성이 없는 조인이 단일 관계 엔터티에 있기 때문에 입력/수정/삭제를 시도하면 이상 현상이 발생한다.

  
  

![](https://i.imgur.com/6t6F0s9.png)

(그림) 조인 종속 관계 해결

  

위 그림과 같이 관계 엔터티를 각각 독립적 관계로 해소함으로써 이상 현상을 해결할 수 있다. 모두 조인 시 원래의 릴레이션으로 구성할 수 있으므로 세 개의 릴레이션은 제 5 정규형을 만족한다.

  
  

### 역정규화

역정규화(denormalization)는 정규화된 테이블을 낮은 정규화 단계의 테이블로 되돌리는 것으로, 읽기 성능을 향상시킬 때 사용한다. 정규화를 수행하면 테이블이 분해되므로 필요한 결과 데이터를 얻기 위해 조인 연산을 여러 번 수행해야 한다. 이 때문에 데이터베이스를 빈번히 조회하는 경우 성능 저하가 생길 수 있다. 그래서 오히려 중복을 허용하는 역정규화를 수행한다.

  
  
  

---