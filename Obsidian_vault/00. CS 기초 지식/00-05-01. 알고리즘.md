# 5.1. 정렬 알고리즘

**[정렬 알고리즘 구분]**
1. 비교하는 정렬 알고리즘
	- 버블 정렬, 선택 정렬, 삽입 정렬, 합병 정렬, 힙 정렬, 퀵 정렬 등
2. 비교하지 않는 정렬 알고리즘
	- 계수 정렬, 기수 정렬 등
- 기술 면접 시 간단한 정렬 알고리즘을 손코딩하거나, 주어진 문제를 정렬 알고리즘으로 해결하는 문제 출제

### 5.1.1. 버블 정렬(Bubble sort) ⭐️⭐️

- 비교 기반 정렬 알고리즘
- **양옆에 위치한 두 값을 비교**하면서 크기 순으로 정렬
- 배열의 뒤에서부터 정렬됨
- 버블 정렬은 정렬을 수행하는데 비교적 느린 편이지만, 별도의 **메모리 공간 불필요**

#### 오름차순 버블 정렬 작동 방식
- 배열에서 연속된 인덱스의 두 값을 차례대로 a, b라고 했을 때, b > a 이면 정렬되었다고 판단함
- b < a 이면 a와 b의 위치를 바꿔 정렬을 수행함
- 위 작업을 정렬이 완료될 때까지 수행

	<버블 정렬 예시>
	- 배열 [5, 3, 8, 1, 2] 버블 정렬
		![|300\*300](https://i.imgur.com/aX9v4mH.png)
		
	1. 5와 3을 비교했을 때 5 > 3이므로 두 수의 위치를 교환
	2. 5와 8을 비교했을 때 5 < 8이므로 위치 교환X
	3. 8과 1을 비교했을 때 8 > 1이므로 두 수의 위치를 교환
	4. 8과 2를 비교했을 때 8 > 2이므로 두 수의 위치를 교환
	5. 배열의 마지막 인덱스부터 정렬됨
	
	→ 위의 과정을 거치면 최댓값인 8이 배열의 마지막에 위치함
	→ 즉, 배열의 첫 번째 ~ n번째 요소까지 오름차순으로 버블 정렬을 수행하면 **최댓값이 n번째에 위치**하게 됨
	- 배열의 n번째 요소를 정렬하는 데 (n-1)번을 비교하므로, 배열의 모든 요소를 정렬하려면 
	  (n-1) + (n-2) + ... + 2 + 1 = **n(n-1)/2** 만큼 연산을 수행해야 함 
	- 이때 시간 복잡도는 **𝑂(𝑛^2)** 소요

---

### 5.1.2. 선택 정렬(Selection sort) ⭐️⭐️

- 비교 기반 정렬 알고리즘
- 배열을 순회하면서 **배열의 앞에서부터 차례대로 각 인데스에 들어갈 값을 선택**해 위치시킴
- 오름차순 정렬 : 배열 첫 번째 자리에 최솟값을, 두 번째 자리에는 최솟값 다음으로 작은 값을 위치시킴
- 버블 정렬과 같이 정렬을 수행하는데 느린 편이지만, 별도의 **메모리 공간이 필요하지 않고 구현도 간단한 편**

#### 선택 정렬 작동 방식
- 인덱스 i에 들어갈 값을 선택하는 경우, i-1까지는 정렬이 완료된 상태임
- 따라서 인덱스 i부터 마지막 인덱스까지의 요소 중 최솟값을 선택
- 선택한 최솟값과 인덱스 i에 담긴 값의 위치를 교환
- 위의 방식으로 배열을 순회하면서 마지막 인덱스까지 정렬을 수행
	![|550\*550](https://i.imgur.com/613zb7u.png)
	
	<선택 정렬 예시>
	- 배열 [5, 3, 8, 1, 2] 선택 정렬
		![|300\*300](https://i.imgur.com/1E7bRoG.png)
		
	1. 배열 첫 번째 자리에 가장 작은 값인 1을 위치시킴
	2. 배열 두 번째 자리에 1을 제외한 나머지 값 중 가장 작은 2를 위치시킴
	3. 배열 세 번째 자리에 1, 2를 제외한 나머지 값 중 가장 작은 3을 위치시킴
	4. 배열 네 번째 자리에 1, 2, 3을 제외한 나머지 값 중 가장 작은 5를 위치시킴
	5. 배열 다섯 번째 자리에 1, 2, 3, 5를 제외한 나머지 값 중 가장 작은 8을 위치시킴
	
	→ 위와 같이 선택 정렬은 배열을 순회하면서 각 인덱스에 최솟값을 위치시킴
	- 배열의 크기를 n이라고 할 때, 각 인덱스 i에 드어갈 숫자를 찾기 위해 n-i개의 값을 비교
	- 따라서 배열 전체에 대한 정렬을 완료하려면 
	  (n-1) + (n-2) + ... + 2 + 1 = **n(n-1)/2** 번 연산을 수행해야 하고, 시간 복잡도는 **𝑂(𝑛^2)** 소요

---

### 5.1.3. 삽입 정렬(Insertion sort) ⭐️⭐️

- 비교 기반 정렬 알고리즘
- 배열을 **앞에서부터 순회하면서 정렬된 부분의 적절한 위치에 값을 삽입**하는 방식 

#### 오름차순 삽입 정렬 작동 방식
- 인덱스 i에 있는 a를 정렬할 차례일 때, 인덱스 0부터 i-1까지는 이미 정렬된 상태
- 정렬된 부분에서 a보다 작거나 같은 수와 a보다 큰 수 사이에 a를 삽입
	![|500\*500](https://i.imgur.com/Zu4WPpC.png)
	
	<삽입 정렬 예시>
	- 배열 [5, 3, 8, 1, 2] 삽입 정렬
		![|300\*300](https://i.imgur.com/Y1hdawp.png)
		
	1. 배열에서 정렬된 부분이 [5]일 때 두 번째 요소인 3은 적절한 위치인 5 앞에 삽입
	2. 세 번째 요소인 8은 정렬된 [3, 5]에서 5 뒤가 적절한 위치이므로 현재 위치를 유지
	3. 네 번째 요소인 1은 정렬된 [3, 5, 8]에서 적절한 위치인 3 앞에 삽입 
	4. 다섯 번째 요소인 2는 정렬된 [1, 3, 5, 8]에서 적절한 위치인 1과 3 사이에 삽입
	5. 배열의 마지막 요소까지 정렬되어 연산을 종료
	
	→ 위와 같이 삽입 정렬은 전체 배열을 순회하며 각 순회에서 인덱스 i 요소를 적절한 위치에 삽입하기 위해 
	최대 n-1번을 탐색함
	- 따라서 1 + 2 + ... + (n-2) + (n-1) = **n(n-1)/2** 번 연산을 수행하며, 시간 복잡도는 **𝑂(𝑛^2)** 소요

---

### 5.1.4. 합병 정렬(Merge sort) ⭐️⭐️⭐️

- 비교 기반 정렬 알고리즘
- **재귀를 이용하는 분할 정복 알고리즘**
	- 분할은 배열을 쪼개는 것이고, 정복은 분할한 배열을 정렬하면서 하나로 합병하는 것을 의미
	- 정렬하려는 배열을 크기가 0 또는 1이 될 때까지 절반씩 분할함
- 분할된 각각의 배열은 다시 하나의 배열로 합쳐지면서 정렬을 수행

💡 분할 정복 알고리즘(divide and conquer algorithm)
	- 해결하기 어려운 문제를 작은 문제로 분할해 해결하는 방식 
	- 주로 재귀함수로 구현하며 대표적인 예시는 합병 정렬
 
#### 합병 정렬 작동 방식
- 하나의 리스트를 두 개의 균등한 크기로 분할하고, 분할된 부분 리스트들을 정렬한 다음에
- 정렬된 부분 리스트들을 하나로 합치면서 **전체가 정렬된 리스트**가 되게 하는 방식

	<합병 정렬 - 분할 예시>
	- 아래와 같은 배열 [8, 3, 2, 1, 7, 6, 4, 5]을 합병 정렬 한다면, 먼저 재귀함수를 호출해 배열을 분할함
	- ④와 같이 배열 크기가 1 이하가 되면 분할을 종료
		![|350\*350](https://i.imgur.com/FvSbYUB.png)
	- 분할을 마친 각 배열을 다시 하나로 합병하면서 정렬을 수행
		- 이때 합병하려는 두 배열과 두 배열을 합친 크기의 빈 배열이 필요함
	- 합병하려는 두 배열은 정렬이 완료된 상태이며, 각 배열의 앞에 있는 요소부터 비교하면서 정렬 
	-  오름차순이면 두 배열의 앞에 있는 요소 중 작은 숫자를 빈 배열에 넣음
		- 내림차순이면 큰 숫자를 빈 배열에 넣음
	-  오름차순으로 정렬한다면 합병 방식은 아래와 같음
	
	<합병 정렬 예시>
	- 위에서 분할된 크기가 1인 부분리스트들을 합치면서 정렬 시작
	- 동일한 크기로 합침 : 크기 1인 8개 서브리스트들을 크기 2인 리스트 4개로 합치는 방식
	- 합쳐지면서 각 원소들은 자신의 위치에 정렬 → 합쳐진 서브 배열들은 정렬된 상태를 유지하게 됨
	- 배열 [6, 7], [4, 5] 합병 정렬
		![|400\*400](https://i.imgur.com/xMkIQGX.png)
		
	1. [6, 7]과 [4, 5] 두 배열을 정렬하려면 크기가 4인 빈 배열을 준비
		- 두 배열의 첫 번째 요소인 6과 4를 비교 : 4가 작으므로 정렬을 위한 배열에 4를 삽입
	2. [6, 7]과 [5]에서 각 배열의 첫 번째 숫자인 6과 5를 비교 : 5가 작으므로 정렬을 위한 배열에 5를 삽입
	3. [6, 7]과 빈 배열만 남았으므로 정렬을 위란 배열에 6을 삽입
	4. [7]과 빈 배열만 남았으므로 정렬을 위한 배열에 7을 삽입하고 정렬을 종료
	
	→ 위와 같은 방식으로 분할한 배열을 다시 합병하면서 정렬 수행
	→ 연산이 끝나면 아래와 같은 오름차순으로 정렬된 하나의 배열을 얻게됨
		![|400\*400](https://i.imgur.com/qHlvDEr.png)
	- 합병 정렬의 시간 복잡도는 **𝑂(𝑁𝑙𝑜𝑔𝑁)** 으로 수행 시간 면에서 효율적
		- 배열 정렬할 때 시간 복잡도 : 𝑂(𝑛)
		- 배열 분할 또는 합병 시 시간 복잡도 : 𝑂(𝑁𝑙𝑜𝑔𝑁) 
		- 합병 단계에서 배열의 정렬이 일어나므로 합병 정렬하는 데 총 𝑂(𝑁𝑙𝑜𝑔𝑁) 시간 복잡도 소요

**[크게 보면 아래와 같은 구조!]**
	![500](https://i.imgur.com/jvKMQpi.png)
	
[아래 표는 참고용으로 첨부]
![500](https://i.imgur.com/dsNIod2.png)

---
