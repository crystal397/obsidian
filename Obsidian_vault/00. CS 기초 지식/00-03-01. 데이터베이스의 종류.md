# 3.1. 데이터베이스의 종류

- 대표적인 데이터베이스 종류
	- 계층형 데이터베이스, 네트워크형 데이터베이스, 관계형 데이터베이스, NoSQL
	- 관계형 데이터베이스와 NoSQL이 주로 쓰임

### 3.1.1. 데이터베이스란 ⭐️

- 데이터베이스(database) : 사용자나 프로그램에서 사용하기 위해 저장 및 관리하는 데이터 집합
- 목적에 맞춰 대용량 데이터를 저장하고 관리

#### 데이터베이스의 특징
- **실시간 접근** : 데이터베이스에 언제든지 접근해 필요한 처리를 함
- **동시 공유** : 여러 사용자 데이터베이스에 접근 가능
- **지속적 변화** : 데이터의 갱신, 삽입, 삭제 등을 통해 계속 변화
- **내용 기반 참조** : 데이터의 값을 이용해 데이터에 접근 가능
#### 데이터베이스의 개념적 요소
- **개체(entity, 엔티티)**
	- 데이터로 표현하려는 대상을 의미
	- 하나 이상의 속성으로 구성
- **속성(attribute)**
	- 개체의 특성과 상태를 나타냄
	- 데이터베이스를 구성하는 가장 작은 논리적 단위
-  **관계(relationship)**
	- 개체 간에 어떤 관련이 있는지를 나타냄
	- 주로 동사로 표현
#### 스키마(schema)
- 스키마는 **데이터베이스의 전체적인 논리적 설계**를 의미 
  → 데이터 객체, 이들의 속성, 속성 간의 관계, 데이터 관계들이 갖는 제약 조건에 관한 정의를 포괄하는 개념
- 데이터베이스의 전체적인 구조와 제약 조건을 명시하기위해를 사용
- 데이터의 구조, 표현방식, 제약조건을 정의하는 역할
- 스키마의 종류
	- **외부 스키마** : 사용자 측면에서 데이터베이스의 전체 구조
	- **개념 스키마** : 데이터베이스의 전체 구조
	- **내부 스키마** : 물리적 저장장치 측면에서 데이터베이스의 구조

---

### 3.1.2. 관계형 데이터베이스 ⭐️⭐️⭐️

- 관계형 데이터베이스(RDB, Relational Database)
	- 데이터가 2차원 테이블에 저장됨
	- 데이터의 구조와 데이터 간 종속성 등을 알 수 있음
	- 스키마를 바탕으로 데이터베이스의 구조를 정의
		- 스키마는 개체-관계 다이어그램(ERD, Entity-Relation Diagram) 또는 문자열로 표현
	- **장점**
		- 데이터의 무결성 보장
		- 데이터의 중복 최소화
		- 데이터베이스 추가 전 유효성 검사를 통해 품질 향상 가능
		- 허가된 사용자들만이 데이터에 접근하게 할 수 있음(보안설정)
	- **단점**
		- 관계를 맺고 있어 JOIN문이 많은 복잡한 쿼리문이 생길 수 있음(수정 어려움)
			- 테이블 간의 관계가 복잡해질수록 성능 저하 문제 발생
		- 수평적 확장이 어렵고 수직적 확장만 주로 가능해 데이터 처리량 성장에 한계
		- 가변성이 있는 데이터의 경우 저장이 쉽지 않음
- **릴레이션(relation)** : 관계형 데이터베이스에서 데이터의 개념적 모델(데이터를 테이블 형태로 표현)
- **테이블(table)** : 릴레이션을 실제로 구현한 개체
	- 관계형 데이터베이스는 테이블을 이용해 데이터의 종속성과 관계를 나타냄
- 테이블은 키와 값으로 이루어진 2차원 형태로, 행과 열로 구성됨
	- **행(row)** : 데이터 묶음,  **튜플(tuple)** 또는 **레코드(record)** 라고도 함
	- **열(column)** : 이름과 타입을 가진 데이터의 **속성(attribute)**,  **필드(filed)** 라고도 함
		![400](https://i.imgur.com/djOLU6B.png)
		![500](https://i.imgur.com/mHqZ1Cd.png)

##### 용어사전
- 키(key) : 테이블의 행을 식별할 수 있는 속성으로, 테이블의 열에 속함
- 값(value) : 속성이 갖는 실제 데이터

----

### 3.1.3. NoSQL 데이터베이스 ⭐️⭐️

- NoSQL(Not Only SQL)
	- 비관계형 데이터베이스로, 보다 유연한 형태의 데이터베이스를 의미
	![600](https://i.imgur.com/nhJKcGb.png)
	- 대용량 데이터를 조회할 때 속도 면에서 유리
	- 수평적 확장성이 좋아 서버를 추가해 데이터베이스 확장하기 쉬움
	- 데이터 확장성과 대용량 데이터 조회가 빈번히 일어나는 경우에 사용
	- 대량의 분산된 데이터를 저장하고 조회하는 데 특화됨
	- 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소
	- **장점**
		- Big Data 처리에 효과적
		- 비정형 데이터 구조 설계로 설계 비용 감소
		- 가변적인 구조로 데이터 저장이 가능
		- 데이터 모델의 유연한 변화가 가능
	- **단점**
		- 데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능
		- 많은 인덱스를 사용하려면 충분한 메모리가 필요 (인덱스 구조가 메모리에 저장)
		- 데이터 일관성이 항상 보장되지 않음
#### 하나 더 알기 : 계층형 데이터베이스
- 데이터 간에 부모- 자식 관계를 갖는 트리 형태의 데이터베이스
- 개체간 1:N 관계를 갖기 때문에 일대다 관계라고도 함
- 부모 테이블은 하나 이상의 자식 테이블들과 관계를 맺을 수 있지만, 자식 테이블은 오직 하나의 부모 테이블에 한해 관계를 맺을 수 있음
- **장점**
	- 데이터를 빠르게 검색 할 수 있고(액세스 속도 빠름), 데이터의 사용량을 쉽게 예측 가능
- **단점**
	- 상하 종속적인 관계로 구성되어 있어 초기 세팅 후 변화하는 프로세스를 수용하기 어려움
	![300](https://i.imgur.com/mAipiGo.png)
	![500](https://i.imgur.com/9cSm32V.png)
#### 하나 더 알기 : 네트워크형 데이터베이스
- 트리 형태의 데이터베이스나 계층형 데이터베이스와 달리 개체 간에 N:M 관계를 갖는 그래프 구조를 이룸
- 그래프 구조를 기반으로 하며, 개체 간 관계를 그래프 구조로 연결하기 때문에 자식 개체가 여러 부모 개체를 가질 수 있다는 점에서 계층형 데이터 모델과 차이가 있음
- **장점**
	- 데이터를 빠르게 찾을 수 있고, 복잡한 쿼리를 만들고 사용할 수 있음 
- **단점**
	- 데이터베이스의 구조를 바꾸기 어려움
	- 구성과 설계가 복잡하고, 궁극적으로 데이터의 종속성을 해결하지 못함
	![300](https://i.imgur.com/8CWzfOu.png)
	![500](https://i.imgur.com/AxdaAqd.png)

---

# 3.2 관계형 데이터 베이스

- 기술 면접에서 출제 빈도가 높다
- 주로 사용하는 개념 : 키, 무결성, 인덱스, ORM

###  3.2.1 키 ⭐️⭐️⭐️

- 데이터베이스에서 튜플을 구분하기 위한 속성 또는 속성의 집합
- **유일성**  : 하나의 키값으로 튜플을 식별할 수 있는 특성
- **최소성**  : 튜플을 식별하는 데 필요한 속성만으로 이루어져 있는 특성
##### DBMS 5가지 키 (데이터 관리 시스템, 데이터 매니지먼트 시스템)
- **슈퍼 키**   
	: 튜플을 식별할 수 있는 키  
	-  유일성 (튜플을 식별할 수 있어서)    
	- 최소성을 만족하지 않아도된다 (후보 키는 만족해야)    
- **후보 키**  
	: 유일성 (튜플을 식별)    
	: 최소성 (필요한 속성으로만 구성)    
- **기본 키**  
	: 후보 키 중에서 메인이되는 키  
	: NULL 값을 가지면 안된다  
- **대체 키**  
	: 후보 키 중 기본 키를 제외한 키  
- **외래 키**  
	: 다른 테이블의 기본 키를 참조하는 키  
	![300](https://i.imgur.com/HEzStLv.png)
	_슈퍼 키 안에 후보 키, 후보키 안에 키본 키와 대체 키_

	![](https://i.imgur.com/FfXcjnG.png)
	_파일 시스템, 데이터베이스 모델링, 관계형 데이터베이스 용어 비교_

### 3.2.2 무결성 ⭐️⭐️

- **정확성** :  저장된 데이터가 실제 데이터와 일치하는지  
- **일관성** : 데이터가 일정하게 유지되는지  
##### 데이터 무결성의 종류
- **개체 무결성**  
	-  모든 테이블이 기본 키를 가져야 한다.  
	-  기본 키의 값은 NULL이 될 수 없다.  
	-  중복되지 않고 고유한 값을 가져야 한다.  
- **도메인 무결성**  
	-  테이블의 속성 값은 도메인에 속해야 한다.  
	-  도메인은 속성이 가질 수 있는 값의 집합  
- **참조 무결성**  
	-  외래 키의 값은 참조하는 테이블의 기본 키 값과 동일하거나 NULL이어야 한다.

### 3.2.3 인덱스 ⭐️⭐️⭐️
##### 인덱스(index, 색인)
- 주소를 저장하는 것
-  속성 값과 튜플이 저장되어있음   
	: 데이터베이스에서 튜플의 검색 성능을 높히기 위해  

-  **키 - 값 형태**
	: 인덱스 테이블에 저장  
	: '속성 값-튜플 주소'   
>인덱스 테이블은 **속성 값을 기준으로 정렬 상태를 유지한다.**

![](https://i.imgur.com/pxO0sRE.png)
_빼빼로 튜플을 제거해도 인덱스는 남아있다_

- **장점** : 데이터가 정렬되어있어서 검색 속도가 빠르다
- **단점**
	- 추가 공간이 필요
		: 인덱스 테이블을 저장해야해서  
	- 데이터를 추가, 수정, 삭제하는 경우에는 속도가 느리다
		: 재정렬해야 하므로  
***
**튜플의 삭제 연산이 발생하는 경우 인덱스 테이블에서 데이터는 '사용하지 않음' 처리가 된다?**
-  실제로 삭제되지 않고 테이블에 남아있다.  

**빼빼로 튜플을 삭제했는데도 인덱스 테이블에는 빼빼로가 남아있다?**
-  삭제 연산이 빈번하게 일어나면 실제 사용하는 데이터는 적어서 성능저하   
(인덱스 테이블의 크기는 일정하다)  
-  데이터 양이 방대하며 검색을 자주하는 경우에 인덱스를 사용하자  
(데이터 변경이 많으면 인덱스 사용을 자제하자)  
![](https://i.imgur.com/nyr3phJ.png)
빼빼로 튜플을 삭제
***
**인덱스를 구현하는 대표적인 방법?**
-  해시테이블, B+- 트리

##### 해시 테이블 인덱스
-  속성 값으로 해시 값을 계산해 인덱싱하는 방법  
***
**검색하려는 값을 온전히 입력할 때만 사용할 수 있다?**
-  해시 함수 특성상 속성 값을 그대로 검색해야해서  
***
**'빼빼로'의 인덱스를 검색하는 것만 가능?**
-  '빼로 시작하는 속성 값'의 인덱스를 찾는건 불가능  
-  검색 속도가 빠른데도 자주 사용하지 않는 방식  
![](https://i.imgur.com/mFhvANF.png)


##### B+- 트리 인덱스  
인덱스 테이블을 구현할 때 트리구조를 많이 사용  
-  B+ 트리 인덱스  
-  B- 트리 인덱스  
(B는 Balanced를 의미)  
***
**B+ 트리?**
-  단말 노드에만 데이터를 저장  
-  단말 노드간에는 연결 리스트로 연결  
***
**B- 트리?**    
-  모든 노드에 데이터를 저장  

### 3.2.4 ORM ⭐️⭐️⭐️

- 객체와 관계형 데이터베이스를 매핑하는 도구 (Object-Relational Mapping)  

![](https://i.imgur.com/KiIc1Pu.png)

**객체 지향 프로그래밍 언어를 이용해 프로그램을 개발할 때 편리하다?**  
- 데이터베이스를 프로그래밍 언어의 객체 관점으로 바라볼 수 있어서  
***
**코드의 가독성을 높이고 개발자 편의성을 증대할 수 있다?**  
-  SQL문을 사용하지 않고 객체 지향적 코드를 작성할 수 있어서  
-  복잡한 프로젝트를 수행할 때는 ORM만으로 서비스를 구현하기 어려울 수 있다.  
***
##### 대표적인 ORM 프레임 워크
- 자바 / 하이버네이트
- 파이썬 / 장고
- 루비 / 액티브 레코드


# 3.3. 트랜잭션

: **트랜잭션(transaction)은 데이터베이스의 상태를 바꾸기 위해 수행하는 작업의 단위, 또는 일련의 연산**을 의미한다. 다음 ACID는 데이터베이스 트랜잭션의 4가지 특성에서 첫 글자를 딴 용어이다.


### 3.3.1. 트랜잭션 ⭐️⭐️
- 데이터베이스의 트랜잭션은 ACID라는 특징이 있음
	- **원자성(Atomicity):** 트랜잭션이 데이터베이스에 완전히 반영되거나 아예 실행되지 않아야 한다.
		- 원자성의 사전적 정의: '어떤 것이 더 이상 쪼개질 수 없는 성질'
		- 티켓 예약 시스템을 원자성의 예로 들 수 있다. 티켓은 지불과 예약이 동시에 되거나, 아니면 모두 되지 않아야 한다. 지불은 되었으나 예매가 되지 않거나, 지불이 되지 않았으나 예매가 되는 경우는 허용되지 않는다.
		- 즉, **어떤 작업이 실행될 때 완전히 진행되고 종료되거나, 그럴 수 없는 경우에는 실행 자체를 하지 않아야 한다.**  
	
	- **일관성(Consistency):** 트랜잭션 수행이 완료된 데이터베이스는 트랜잭션 이전과 이후의 상태에 일관성이 있어야 한다.
		- '모든 고객은 반드시 이름을 가지고 있어야 한다'는 데이터베이스의 규칙을 예로 들 수 있다. '이름 없는 새로운 고객을 추가하는 쿼리' 또는 '기존 고객의 이름을 삭제하는 쿼리'의 트랜잭션은 '이름을 가지고 있어야 한다'는 데이터베이스의 제약을 위반하기 때문에, 데이터베이스는 일관되지 않는 상태를 가지게 된다.
		- 다시 말해, **트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다**는 말이다.
	
	- **독립성(Isolation)**: 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들 수 없다.
		- 계좌 송금 데이터베이스를 예로 들 수 있다. A 계좌에 10,000원이 있다고 가정해보자. B 계좌로 6,000원을, C 계좌로 6,000원을 동시에 계좌이체 하려면 각각의 송금 작업을 연속으로 실행한 것과 동일한 결과가 나타나야 한다. 잔고가 -2,000원이 되는 마이너스 통장이 아니기 때문이다.
		- 격리성을 준수하는 트랜잭션은 철저히 독립적되어야하기 때문에 다른 트랜잭션의 작업 내용을 알 수 없다.
		- 결과적으로 **트랜잭션이 동시에 실행될 때와 연속으로 실행될 때의 데이터베이스 상태가 동일해야 한다**는 것이다.
	
	- **영속성(Durability):** 완료한 트랜잭션의 결과가 데이터베이스에 영구적으로 반영된다.
		- 예를 들어, 은행에서 계좌이체를 완료한 뒤에 은행 데이터베이스에 오류가 발생해 종료되더라도 계좌이체 내역은 로그가 남아야 한다.
		- 마찬가지로 계좌이체 로그를 기록하기 전에 시스템 오류로 종료된다면, 이체 내역은 실패로 기록되고 각 계좌들은 이전 상태로 돌아가야 한다.
		- 즉, 트랜잭션이 성공적으로 수행되었다면 해당 트랜잭션에 대한 로그가 남아야 하는 성질을 설명하는 것이다. Runtime error나 System error가 발생하더라도 기록은 영구적이어야 한다는 뜻이다.

==원자성 때문에 트랜잭션은 완전히 반영되거나 아예 실행되지 않아야 한다.==
따라서 트랜잭션을 제어하기 위해 TCL(Transaction Control Language)이라는 명령어를 사용한다.

#### TCL의 종류
- COMMIT: 트랜잭션이 정상적으로 종료되어 데이터베이스에 변경 사항을 반영하는 명령어다.
- ROLLBACK: 트랜잭션이 비정상적으로 종료되어 트랜잭션이 수행한 변경 사항을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어다.
- SAVEPOINT: 트랜잭션에서 특정 지점을 지정하는 명령어로, ROLLBACK과 함께 사용하면 해당 지점까지 되돌릴 수 있다.
---
##### 하나 더 알기
- 트랜잭션이 수행되는 단계와 각 단계에서의 상태는 다음과 같다.

![500](https://i.imgur.com/7pWUb5R.png)

(그림) 트랜잭션 수행 단계와 상태

- **활성화:** 트랜잭션이 시작되어 처리 중인 상태
- **부분적 완료:** 트랜잭션의 마지막 연산까지 처리가 완료되었지만 데이터베이스에 트랜잭션 수행 결과가 반영되지 않은 상태
- **완료:** 트랜잭션의 연산 처리가 완료되고 데이터베이스에 결과가 반영된 상태
- **실패:** 트랜잭션 처리 중 오류가 발생해 트랜잭션이 중단된 상태
- **철회:** 트랜잭션이 중단되어 ROLLBACK을 수행해 데이터베이스를 이전으로 되돌린 상태

##### 깊게 알기: 트랜잭션 격리

여러 트랜잭션이 서로 영향을 미치지 않고 실행될 수 있는 단계를 **트랜잭션 격리 수준(transaction isolation level)** 이라고 한다. 이는 한 트랜잭션이 다른 트랜잭션 작업의 조회 가능 여부를 결정한다. 트랜잭션 격리 수준은 다음과 같이 4단계로 나뉜다.

![](https://i.imgur.com/6aczckk.png)

(그림) 트랜잭션 격리 수준

- **Read Uncommited:** 트랜잭션의 COMMIT 여부와 상관없이 다른 트랜잭션이 데이터를 조회할 수 있다. 한 번에 여러 트랜잭션을 처리할 수 있는 동시성은 높지만, 데이터의 일관성을 유지하기 어렵다.
- **Read Commited:** 트랜잭션이 COMMIT된 데이터만 다른 트랜잭션이 조회할 수 있다.
- **Repeatable Read:** 트랜잭션이 읽은 데이터를 다른 트랜잭션이 갱신하거나 삭제할 수 없다.
- **Serializable:** 트랜잭션이 읽은 데이터를 다른 트랜잭션이 갱신, 삭제, 삽입할 수 없다.  

- 동시성이 높아지면 여러 트랜잭션이 동시에 처리되고 데이터의 일관성에 문제가 발생할 확률도 높아진다.
- 반면에 고립성을 높이면 하나의 트랜잭션이 처리 중일 때 다른 트랜잭션의 접근이 제한되어 효율이 낮아진다.
- 따라서 상황에 따라 데이터의 일관성을 유지하면서 트랜잭션을 효율적으로 처리할 수 있어야 한다.
---

### 3.3.2. 락(Lock)

**락(lock)은 트랜잭션이 처리되는 순서를 보장하기 위한 방법**이다. 운영체제에서 데이터 동기화를 위해 임계 영역에 대한 접근을 제한하는 상호배제 기법과 유사하다. 데이터의 무결성을 유지하기 위한 락이 여러 종류가 있는데, 대표적인 락은 다음과 같다.
- **공유 락(shared lock):** 데이터를 읽는 락으로, 읽기 락(read lock)이라고도 한다. 데이터를 읽는 연산이기 때문에 데이터의 일관성에 영향을 주지 않는다. 따라서 데이터에 여러 공유 락이 동시에 접근할 수 있다.
- **베타 락(exclusive lock):** 데이터를 수정하는 락으로 쓰기 락(write lock)이라고도 한다. 데이터의 일관성을 유지하기 위해서, 특정 데이터에 하나의 베타 락이 접근 중일 때 다른 베타 락이 접근할 수 없다.

데이터베이스의 트랜잭션도 프로세스처럼 교착 상태(deadlock)에 빠질 수 있다. 이는 한 트랜잭션이 자신의 처리 중인 데이터에 대해 락을 가진 상태에서, 다른 트랜잭션이 처리 중인 데이터에 락을 요청해 ==무한 대기 상태에 빠진 현상==을 의미한다. 즉, 특정 데이터의 락을 가지고 있는 트랜잭션이 다른 데이터의 락을 추가로 요청하며 발생하는 현상이다.

#### 트랜잭션 교착 상태 해결 방법

1. **예방 기법**
	- 트랜잭션 처리가 시작되기 전에 필요한 데이터에 대해 미리 락을 얻는 방식이다.
2. **회피 기법**
	- 트랜잭션이 들어온 순서에 따라 교착 상태를 회피하는 방식이다.
	- **wait-die:** 데이터의 락을 요청하려는 트랜잭션이 해당 데이터에 대해 이미 락을 갖고 있는 트랜잭션보다 오래되었다면 락을 얻을 때까지 기다린다. 반면, 락을 갖고 있는 트랜잭션보다 최신이라면 락 획득을 포기한다.
	- **wound-wait:** 데이터의 락을 요청하려는 트랜잭션이 해당 데이터에 대해 이미 락을 갖고 있는 트랜잭션보다 오래되었다면 락을 빼앗는다. 반면, 락을 갖고 있는 트랜잭션보다 최신이라면 락 획득을 기다린다.

---
### 3.3.3. 이상(anomaly) ⭐️⭐️⭐️

이상(anomaly)은 ==트랜잭션을 처리하는 중에 속성 간 종속이나 데이터 중복으로 발생하는 문제==를 말한다. 여기에는 3가지가 있다.
- **삽입 이상(insertion anomaly):** 데이터 삽입 시 의도치 않은 다른 데이터도 삽입된다.
- **갱신 이상(update anomaly):** 데이터 갱신 시 일부 튜플만 갱신되어 데이터 모순이 발생한다.
- **삭제 이상(deletion anomaly):** 데이터 삭제 시 의도하지 않은 데이터도 삭제된다.
---
### 3.3.4. 정규화 ⭐️⭐️

정규화(normalization)는 ==데이터베이스의 이상 현상을 해결하기 위해 테이블을 분해하는 것==이다. 하지만 테이블을 분해하느라 연산 시간이 증가한다는 단점이 있다. 그렇기 때문에 테이블이라고 무조건 분해하는 것이 아니라, 상황에 따라 적절하게 정규화를 진행시켜야 한다. 이렇게 함으로써 이상 현상도 해결하면서 연산 속도 또한 보장할 수 있다.

이렇게 정규화한 결과를 **정규형(normal form)** 이라고 하며, 테이블을 분해하는 정도에 따라서 단계를 다음과 같이 나눌 수 있다(예시는 데이터베이스 내 데이터의 수정을 고려하지 않는다는 것을 전제로 작성되었다.).  

![500](https://i.imgur.com/WbngmVM.png)

(그림) 정규화 단계

#### 제 1 정규형

**제 1 정규형(1NF, First Normal Form)** 은 테이블의 ==모든 속성 값이 더 이상 분해될 수 없는 값, 즉 원자값으로 구성==되어야 한다. 예를 들어, 다음 그림을 보면 왼쪽 테이블에 (롯데, (칸쵸, 빼뺴로))와 같이 '과자 이름' 속성에 속성 값이 2개 존재한다. (오리온, (꼬북칩, 다이제))도 마찬가지로 속성 값이 2개이므로 원자 값이 되도록 테이블을 분해하는 제 1 정규화를 수행하면 속성 값 2개가 각각 튜플로 나눠지게 된다. 그러면 오른쪽에 있는 제 1 정규형 테이블을 만들 수 있다. 
![500](https://i.imgur.com/3dbRd5Z.png)

(그림) 제 1 정규형의 예

#### 제 2 정규형

제 2 정규형(2NF, Second Normal Form)은 제 1 정규형에 속하는 테이블에서 ==부분적 함수 종속을 제거==해 완전 함수 종속을 만족해야 한다. 함수 종속성은 테이블에서 속성 간의 종속 관계를 의미한다.  
![400](https://i.imgur.com/ozX783Z.png)

(그림) 함수 종속  

예를 들어, X 속성이 Y 속성을 결정하면 Y 속성은 X 속성에 함수 종속된다고 한다. 그리고 X를 결정자, Y를 종속자라고 한다. 

**완전 함수 종속**은 X 속성이 Y 속성을 결정하지만, X 속성의 진부분집합(자기 자신을 제외한 부분집합)이 Y 속성을 결정하지 않는 경우를 말한다.

따라서 **부분적 함수 종속**은 기본 키의 부분 집합이 결정자가 될 수 있음을 의미한다. 즉, ==기본 키의 진부분집합이 결정자가 될 수 없도록 테이블을 분해해야 완전 함수 종속을 만족한다==.

예를 들어, 제조사에 따라 과자의 판매처가 정해진다고 가정해 보자. 제조사가 롯데인 경우 롯데마트에서만 판매하고, 그 외 제조사 제품은 E마트에서만 판매한다. 다음 테이블에서 기본 키는 '제조사'와 '과자 이름' 속성이다. 가격 속성은 제조사와 과자 이름으로 정해지지만, 판매처는 제조사로만 정해진다. 즉, 기본 키의 부분 집합인 제조사가 판매처를 결정하는 결정자가 된다. 따라서 이를 제 2 정규화하면 다음과 같다.
![](https://i.imgur.com/emMCY8F.png)

(그림) 제 2 정규형 

이와 같이 판매처에 대한 테이블을 분리해 완전 함수 종속을 만족시킬 수 있다.
##### 용어사전
- 부분집합: 집합 A의 모든 원소가 집합 B에 포함될 때, 집합 A를 집합 B의 부분집합이라고 한다.
- 진부분집합: 집합 A가 집합 B의 부분집합이면서 집합 B와 같지 않을 때, 집합 A를 집합 B의 진부분집합이라고 한다.

#### 제 3 정규형

**제 3 정규형(3NF, Third Normal Form**)은 제 2 정규형에 속하는 테이블에서 ==이행적 종속이 없어야 한다==. 이행적 종속은 A 속성이 B 속성을 결정하고 B 속성이 C 속성을 결정할 때, A 속성이 C 속성을 결정하는 것을 의미한다. 이런 경우 A 속성이 C 속성을 결정하는 이행적 종속을 제거해야 한다.

즉, A 속성이 B 속성을 결정하는 테이블과, B 속성이 C 속성을 결정하는 테이블로 분해해야 한다.
다음 예시에서는 고객 한 명당 과자 하나만 구매할 수 있다고 전제한다.  

![](https://i.imgur.com/65O1rD8.png)

(그림) 이행적 종속이 있는 테이블 예시

해당 테이블에서 이행적 종속은 다음과 같다. 과자 이름은 고객이 구매한 과자로 결정된다. 과자 이름은 가격을 결정한다. 고객 한 명당 과자를 하나만 구매할 수 있으므로 고객이 가격을 정하는 것처럼 종속 관계를 갖게 된다. 이러한 경우 이상이 발생하기 쉽다.

예를 들어, 칸쵸의 금액이 인상되었지만 칸쵸를 구매한 일부 고객의 구매 금액만 갱신된다면 갱신 이상이 발생한다. 따라서 이행적 종속을 제거하고 정규화하면 다음과 같다.
![400](https://i.imgur.com/hn7loiP.png)

(그림) 제 3 정규화를 적용한 결과

#### 보이스-코드 정규형

보이스-코드 정규형(BCNF, Boyce-Codd Normal Form)은 강한 제 3 정규형이라고도 한다. 이 유형은 제 3 정규형에 속하는 ==테이블의 모든 결정자가 후보키가 되도록 테이블을 분해==해야 한다.

다음 그림의 예시를 보면, 학번과 과목을 기본 키로 교수 속성의 값을 결정한다. 하지만 교수는 과목 속성을 결정하는 결정자이기도 하다. 따라서 결정자가 후보 키가 아니므로 BCNF를 만족하지 못한다.
![](https://i.imgur.com/D5UcLCu.png)

(그림) BCNF 필요 예시

이 테이블에 BCNF 정규화를 진행하면 결과는 다음과 같다.
![500](https://i.imgur.com/iL4yDJN.png)

(그림) BCNF 정규화 결과

---

##### 하나 더 알기
#### 제 4 정규형

제 4 정규형(4NF, Fourth Normal Form)은 제 3 정규형에 속하면서 다치 종속을 제거해야 하는 유형이다. 다치 종속이란, 테이블에서 한 속성이 여러 속성의 값을 결정하는 것을 의미한다.(多値, 많을 다 + 값 치)

다음 예시에서 왼쪽 테이블을 제 3 정규화까지 진행하면 오른쪽 테이블이 된다. 오른쪽 테이블에서는 학생이 전공과 취미라는 두 가지 속성을 결정하고 있다. 즉, 다치 종속이 존재한다.![](https://i.imgur.com/t466TDe.png)
(그림) 다치 종속이 있는 테이블의 예시 

다치 종속을 제거하려면 다음과 같이 학생이 전공을 결정하는 테이블 + 학생이 취미를 결정하는 테이블로 각각 분해한다. 

![](https://i.imgur.com/oxopAyp.png)

(그림) 제 4 정규화 결과. 다치 종속을 제거한 정규화

#### 제 5 정규형

제 5 정규형(5NF, Fifth Normal Form)은 제 4 정규형에 속하면서 조인 종속이 없어야 한다. 조인 종속이 없다는 것은 테이블을 분해했다가 조인할 때 테이블이 복원된다는 것을 의미한다. 

![](https://i.imgur.com/wOPEFf9.png)

(그림) 조인 종속 관계

위 예시를 보면 개발자와 자격증, 개발자와 언어는 관계가 있으나 자격증과 언어는 관계가 없다. 연관성이 없는 조인이 단일 관계 엔터티에 있기 때문에 입력/수정/삭제를 시도하면 이상 현상이 발생한다.
![500](https://i.imgur.com/6t6F0s9.png)

(그림) 조인 종속 관계 해결

위 그림과 같이 관계 엔터티를 각각 독립적 관계로 해소함으로써 이상 현상을 해결할 수 있다. 모두 조인 시 원래의 릴레이션으로 구성할 수 있으므로 세 개의 릴레이션은 제 5 정규형을 만족한다.

#### 역정규화

역정규화(denormalization)는 정규화된 테이블을 낮은 정규화 단계의 테이블로 되돌리는 것으로, 읽기 성능을 향상시킬 때 사용한다. 정규화를 수행하면 테이블이 분해되므로 필요한 결과 데이터를 얻기 위해 조인 연산을 여러 번 수행해야 한다. 이 때문에 데이터베이스를 빈번히 조회하는 경우 성능 저하가 생길 수 있다. 그래서 오히려 중복을 허용하는 역정규화를 수행한다.

---