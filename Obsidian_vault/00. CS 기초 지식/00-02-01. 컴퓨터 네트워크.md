# 2.3. HTTP

### 2.3.1. HTTP(HyperText Transfer Protocol) ⭐️⭐️⭐️

- 인터넷상에서 데이터를 전송하기 위한 프로토콜
- TCP/IP 4계층에서 응용 계층에 속함
  ![|500\*500](https://i.imgur.com/wWO4tp4.png)
- HTTP 특징
    1. **비연결성(connectionless)**
        - 클라이언트에서 요청을 보낸 후 서버로부터 응답을 받으면 연결을 끊는 것을 의미
        - 불특정 다수를 대상으로 하는 서비스에 유리
        - 서버에서 응답을 받고 나서도 연결을 유지하려면 그만큼 자원을 사용하기 때문에 **비연결성은 연결을 유지하지 않음으로써 자원을 절약**
	        - 요청을 주고받을 때만 연결을 유지하고 **응답을 받고 나면 TCP/IP 연결을 끊음** 
	          → 이를 통해 최소한의 자원으로 서버를 유지
        - 단점 : 연결을 유지하지 않기 때문에 서버가 클라이언트를 기억할 수 없으며, 동일한 클라이언트에서 연속적으로 요청이 오면 연결과 연결 해제 과정을 반복하여 자원을 낭비함
	        - 트래픽이 많지 않고 빠른 응답을 제공할 수 있는 경우 효율적으로 작동하며, 트래픽이 많고 큰 규모의 서비스를 운영할 때 비연결성은 한계를 보임
	        - 웹 브라우저로 사이트를 요청하면 HTML, CSS, JavaScript, 추가 이미지 등 수많은 자원이 함께 다운로드 되는데, 이러한 자원들을 각각 보낼 때마다 연결을 끊고 다시 연결하고를 반복하는 것은 매우 비효율적
        - 단점 보완 : 일정 시간동안 연결을 유지할 수 있도록 ‘HTTP Keep Alive’를 사용
        
        💡 HTTP Keep Alive : HTTP 연결 시 일정 시간동안 요청을 유지할 수 있도록 사용하는 HTTP 헤더의 일종으로, 클라이언트에서 HTTP 요청을 보낼 때 연결 헤더에 Keep Alive를 추가해서 보내면 서버에서 연결을 유지할 시간을 추가해 응답함
        
    2. **무상태(stateless)**
        - 서버에서 클라이언트의 상태를 저장하지 않는 것을 의미
        - 하나의 질문-답변이 끝났을 때 이전 내용을 기억하지 못하면 고객은 요청 내용을 모두 정리해 한 번에 말해야 함
            → 클라이언트가 요청에 필요한 데이터를 모두 가지고 있거나(=**쿠키**), 서버가 클라이언트로부터 받은 요청사항을 모두 저장해야함(=**세션**)
        - 장점 : **서버 확장성이 용이함**
	        - 클라이언트 요청을 보낼 때, 데이터를 다 담아서 보내기 때문에 같은 기능을 하는 아무 서버나 호출해도 됨
	        - 서버에 장애가 생겨도 다른 서버에서 응답을 전달하기 때문에 클라이언트는 다시 요청할 필요가 없음
	        - 무상태는 응답 서버를 쉽게 바꿀 수 있기 때문에 **무한한 서버 증설**이 가능(스케일 아웃)
	    - 단점 : 클라이언트가 추가 데이터를 전송해야 함
		    - 로그인과 같이 유저의 상태를 유지해야하는 서비스의 경우 브라우저 쿠키, 서버 세션, 토큰 등을 이용해 상태를 유지해야 함
			
        💡 쿠키(cookie) : 클라이언트의 로컬 웹 브라우저에 저장하는 데이터 파일로, 키와 값을 저장함
	    💡 세션(session) : 서버에서 클라이언트와의 연결 정보를 저장 및 관리하는 것을 의미, 서버에 데이터가 저장되므로 보안면에서는 쿠키보다 좋지만 접속자가 많으면 서버에 과부하가 옴
        
		![|500\*500](https://i.imgur.com/efEfNNg.png)
        ▲ HTTP의 특징
***
- HTTP 메세지
    - HTTP에서는 클라이언트와 서버가 통신하기 위해 정형화된 데이터인 HTTP 메시지를 주고 받음(요청 메시지, 응답 메시지)
    - **HTTP 메시지 구조**    
        - **요청 라인(request line)** : 요청 URI, 요청방법, HTTP 버전 등을 포함
        - **상태 라인(status line)** : 요청에 대한 HTTP 상태 코드와 HTTP 버전을 포함
        - **헤더(header)** : 키-값으로 구성된 다수의 헤더 항목으로 구성 
	        - 요청, 응답에 대한 설명 혹은 본문에 대한 설명과 같이 HTTP 전송에 필요한 모든 부가정보를 담는 곳
        - **빈 줄(blank line)** : 헤더의 끝을 나타내는 빈 줄로, 헤더와 바디를 구분 (공백 라인)
        - **바디(body)** : 요청할 때 요청 방법 메서드가 POST인 경우에만 바디가 있고, 그 외 메서드일 때는 비어있는 상태로 전달함
	        - 실제 전송할 데이터를 담는 공간
	        - html, json, 이미지, 영상 등 byte로 표현할 수 있는 모든 데이터를 담아서 전송 가능
	          ![|500\*500](https://i.imgur.com/WW4B1Va.png)
		    ▲ HTTP 메시지 구조
***
- HTTP 상태 코드
	- 클라이언트 요청에 대한 서버의 상태를 알려주는 코드
	- 세 자리 숫자로 표현하며 코드의 시작 숫자로 의미 파악 가능
		- *1xx : 클라이언트로부터 요청을 받아 처리 중*
		- *2xx : 요청을 성공적으로 처리함*
		- *3xx : 요청을 처리하기 위해  추가 처리 필요*
		- *4xx : 클라이언트 오류*
		- *5xx : 서버 오류*
		- 주요 상태 코드
		  ![|500\*500](https://i.imgur.com/W8DwJeH.png)
***

### 2.3.2. HTTPS(HyperText Transfer Protocol Secure) ⭐️⭐️⭐️

- 보안 계층인 **SSL/TLS를 이용해 HTTP의 보안을 강화**한 웹 통신 프로토콜
- 데이터 암호화를 거치지 않고 전송해서 보안에 취약한 HTTP를 보완하기 위해 등장함
- **SSL(Secure Socket Layer)**
    - 넷스케이프에서 개발한 암호화 프로토콜
- **TLS(Transport Layer Security)**
    - SSL의 문제점을 보완한 새로운 암호화 프로토콜
    - 현재 HTTPS에서 통용되는 방식은 TLS지만, SSL 명칭이 사라지지 않아서 SSL 또는 SSL/TLS라고 부름
- HTTPS 동작 방식
    - 데이터를 송신할 때 [응용 계층]에서 [보안 계층]의 SSL/TLS로 데이터를 보내면 데이터를 암호화해 [전송 계층]으로 전달함
    - 전달 받은 후 데이터를 수신할 때 [전송 계층]에서 보낸 데이터를 [보안 계층]의 SSL/TLS에서 받아 복호화한 후 [응용 계층]으로 보냄
***
- SSL/TLS에서 사용하는 2가지 암호화 방식
    1. **`대칭 키 암호화 방식`**
        - 데이터의 암호화와 복호화에 모두 같은 키인 대칭 키를 이용하는 방식
        - 수신자가 같더라도 송신자가 다르면 이용하는 키도 다름
        - 송신자는 받은 키로 데이터를 암호화한 후 수신자에게 보냄 → 수신자는 동일한 키로 데이터를 복호화함
        - 주의점 : 대칭 키가 유출되지 않도록 주의
    2. **`공개 키 암호화 방식`**
        - 데이터의 암호화와 복호화를 다른 키로 하는 방식
        - 데이터를 암호화할 때는 공개 키를, 복호화할 때는 비밀 키를 이용
        - 송신자가 달라도 공개 키는 같음
        - 수신자는 공개 키를 송신자에게 줌 → 송신자는 수신자에게 받은 키로 데이터를 암호화함 → 수신자는 비밀 키로 송신자에게 받은 데이터를 복호화함
        - 비밀 키가 있어야만 데이터를 복호화할 수 있어서 공개 키 유출을 염려하지 않아도 됨
***

### 2.3.3. 웹 페이지 접속 과정 ⭐️⭐️⭐️

- 사용자가 웹 브라우저에 URL 입력 시 화면이 출력되는 과정은 다음과 같음
	  ![|600\*600](https://i.imgur.com/yYnpdmX.png)

1. 사용자가 URL을 웹 브라우저에 입력
2. 웹 브라우저는 입력한 URL을 바탕으로 DNS(Domain Name System) 서버에 연결할 IP를 요청함
3. DNS 서버는 IP 주소를 웹 브라우저에게 응답으로 제공
4. 웹 브라우저는 DNS 서버에서 받은 IP를 통해 웹 서버와 TCP/IP 연결을 하고 HTTP 요청을 보냄
5. 웹 서버는 받은 HTTP 요청에 응답함 (응답은 웹 페이지와 필요한 리소스를 포함)
6. 웹 브라우저는 받은 응답을 바탕으로 사용자에게 웹 페이지를 보여줌