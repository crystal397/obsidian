# 1. 운영체제

### 1.1. 운영체제(OS, Operating System)

- 하드웨어 위에 설치되어 하드웨어와 소프트웨어 계층을 연결하는 소프트웨어 계층
- 역할 : 컴퓨터 시스템 자원 관리, 사용자가 컴퓨터를 사용할 수 있는 환경 제공, 사용자와 컴퓨터 간 인터페이스 제공
- 종류 : Windows, macOS, Linux, Unix 등
- 운영체제 목적
    - 처리능력 향상 : 일정시간 내 시스템이 처리하는 일의 양을 향상시킴
    - 반환시간 단축 : 사용자가 시스템에 요청한 작업의 소요시간 단축
    - 사용 가능도 향상 : 사용자가 시스템 자원을 즉시(빨리) 사용 가능하게함
    - 신뢰도 향상 : 시스템의 문제 풀이 정확도(입력값에 대한 정확한 결과값 제공)

### 1.2. CPU와 메모리 구조

- CPU(Central Processing Unit, 중앙처리장치) : 컴퓨터의 뇌 역할로, 프로그램을 실행하는 데 필요한 연산을 처리하고 수행 (= 프로세서, processor)
- Memory : 데이터를 저장하기 위한 기억장치, 주기억장치(RAM, 휘발성)와 보조기억장치(SSD / HDD, 비휘발성)가 있음
    - 레지스터(register) : CPU 내부에 위치, 요청을 처리하는 데 필요한 데이터를 임시로 저장하며 접근 속도가 빠름
    - 캐시 메모리(cache memory) : CPU 내부에 위치, CPU와 RAM 사이 속도 차이 해결을 위한 기억장치이며 레지스터 다음으로 빠름
    - RAM(Random Access Memory) : 프로그램을 실행할 때 필요한 정보 저장, 캐시 메모리보다 느리고 하드디스크보다 빠름
    - 하드디스크(hard disk) : 사용자가 필요한 데이터와 프로그램을 저장
- Process : 메모리에 로드(load)한 실행 중인 프로그램 (프로그램 실행 → 디스크에 있는 프로그램을 메모리로 로드)

### 1.3. 커널과 시스템 콜 (⭐️⭐️⭐️)

- **커널(kernel)** : OS의 핵심요소, 컴퓨터 하드웨어와 프로세스의 보안, 자원 관리, 하드웨어 추상화 같은 역할 수행
    - 자원 관리 : CPU 스케줄링, 메모리 관리, 입출력 관리, 파일 시스템 관리
    - 커널 모드 : 하드웨어에 직접 접근하여 메모리, CPU와 같은 자원을 사용 가능
    - 사용자 모드 : 커널 모드의 자원에 접근할 수 없게 운영체제가 제한함
- 시스템 콜(system call) : 사용자 모드에서 커널 모드에 접근해 필요한 기능을 수행할 수 있게 하는 시스템 함수
    - 사용자 모드에서 실행된 프로세스가 자원에 접근하려면 시스템 콜을 호출해 커널에 요청해야함
    - e.g. 프로세스 생성 : fork(), 부모 프로세스가 자식 프로세스 수행을 기다림 : wait()
    

# 2. 프로세스

### 2.1. 프로세스와 스레드 (⭐️⭐️⭐️)

- 프로세스(process) : 컴퓨터에서 실행 중인 프로그램
- 프로그램(program) : 특정 작업을 수행하기 위한 명령어의 집합
- 프로세스는 OS로부터 독립된 메모리 영역(stack, heap, data, code)을 할당받으며, 타 프로세스의 메모리 영역에 접근 불가
    - **스택(stack)** : 지역변수, 매개변수, 반환되는 주소 값 등이 저장됨,  높은 주소 값에서 낮은 주소 값으로 메모리가 할당(LIFO, 후입선출)되며 영역 크기는 컴파일 때 결정
    - **힙(heap)** : 사용자 동적 메모리 할당, 낮은 주소 값에서 높은 주소 값으로 메모리가 할당(FIFO, 선입선출)되며 영역 크기는 런타임 때 결정
    - **데이터(data)** : 전역변수, 정적변수, 배열, 구조체 등이 저장됨, 초기화하지 않은 변수를 저장하는 BSS(Block Stated Symbol)와 초기화한 변수를 저장하는 데이터 영역으로 나뉨
    - **코드(code)** : 실행할 코드가 기계어로 컴파일되어 저장됨 (=텍스트 영역)
- 스택 오버플로(stack overflow) : 스택 영역이 힙 영역을 침범하는 경우
- 힙 오버플로(heap overflow) : 힙 영역이 스택 영역을 침범
- 스레드(thread) : 프로세스에서 실제로 실행되는 흐름의 단위
    - 프로세스 안에 존재하므로 프로세스 메모리 공간을 이용
    - 지역변수를 저장하는 스택 영역을 할당받음

### 2.2. PCB (Process Control Block, 프로세스 제어 블록)

- PCB : 프로세스를 제어하기 위해 프로세스 정보를 저장함
    - 저장 정보 : 프로세스의 현재 상태, Process ID, 부모 프로세스의 PID, 자식 프로세스의 PID, 다음 실행할 명령어 주소(PC), 프로세스 우선순위, 메모리 제한 등

### 2.3. 프로세스의 생성 (⭐️⭐️⭐️)

- 새 프로세스는 기존 프로세스에서 fork() 함수를 호출해 생성
    - fork() : 함수를 호출한 프로세스를 복사하는 기능
    - 기존 프로세스 = 부모 프로세스 (parent process)
    - 복사된 프로세스 = 자식 프로세스 (child process)
    - 부모 프로세스는 자식의 PID 값을 반환, 자식 프로세스는 0을 반환
- 부모 프로세스가 자식 프로세스를 종료시키는 case
    - 자식 프로세스가 할당된 자원을 초과해 사용할 때
    - 자식 프로세스에 할당된 작업이 없을 때

### 2.4. 프로세스 상태도 (⭐️⭐️⭐️)

- 프로세스 상태 5가지
    - 생성(new) : 프로세스가 PCB를 갖고 있지만 OS로부터 승인 받기 전인 상태
    - 준비(ready) : OS로 부터 승인받은 후 준비 큐에서 CPU 할당을 기다림
    - 실행(running) : 프로세스가 CPU를 할당받아 실행함
    - 대기(waiting) : 프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 기다림
    - 종료(terminated) : 프로세스 실행 종료
- 프로세스 상태 변화
    - 생성 → 준비 : 생성 상태 프로세스가 OS 승인을 받아 ‘준비 큐(ready queue, 준비 상태의 프로세스가 모여있는 자료구조)’에 추가
    - 준비 → 실행 : 준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 디스패치되어 실행
    - 실행 → 준비 : CPU 독점을 방지하기 위해 타임아웃되어 준비상태로 변경
    - 실행 → 대기 : 입출력 또는 이벤트 때문에 대기 상태로 변경
    - 대기 → 준비 : 입출력 또는 이벤트가 완료되어 준비 상태로 변경
    - 실행 → 종료 : 실행 중인 프로세스가 정상적으로 끝나서 종료 상태로 변경

<aside>
💡 디스패치(dispatch) : 프로세스에 CPU 자원을 할당해 해당 프로세스가 준비 상태에서 실행 상태가 되는 것을 의미

</aside>

### 2.5. 멀티 프로세스와 멀티 스레드 (⭐️⭐️⭐️)

<aside>
💡 동시성(concurrency) : 하나의 코어(싱글 코어)에서 여러 작업을 번갈아 가면서 처리하는 방식
</aside>
- CPU는 한 번에 하나의 작업만 처리 가능 → 여러 작업을 조금씩 돌아가면서 처리함
- 콘텍스트 스위칭 : 하나의 CPU에서 여러 작업을 번갈아 가며 처리하기 위해 처리 중인 작업을 교체하는 것


<aside>
💡 병렬성(parallelism) : CPU가 여러개(멀티 코어) 있어서 각 CPU에서 각 작업을 동시에 처리하는 방식 
</aside>
	→ 물리적인 시간 관점에서 동시에 여러 작업을 처리

- **멀티 프로세스(multi process)** : 응용 프로그램 하나를 여러 프로세스로 구성하는 것
    - 장점 : 한 프로세스가 죽어도 다른 프로세스에 영향을 미치지 않음
        → 응용 프로그램을 여러개로 구성하는 것이 안정적
    - 단점 : 시간과 메모리 공간을 많이 사용함
    - 오버헤드(overhead) : 기존 프로세스가 할당받은 메모리 영역을 다른 프로세스에서 사용할 수 있게 교체하기 위해 필요한 시간과 메모리 (=**어떤 처리를 하기 위해 들어가는 간접적인 처리 시간·메모리)**
    - IPC(Inter Process Communication) : 프로세스 간 통신/자원 공유, 프로세스들 사이에 서로 데이터를 주고받는 방법
- **멀티 스레드(multi thread)** : 스레드를 여러개 생성해 스레드들이 각자 다른 작업을 처리하는 것
    - 장점 : 스레드 간에 힙, 데이터, 코드 영역을 공유하여 콘텍스트 스위칭 시 오버헤드 적게 발생, IPC를 사용하지 않아 멀티 프로세스 단점을 보완
        → 프로세스를 여러개 생성하는 것 보다 스레드를 여러개 생성하는 것이 자원 효율적이며, 스레드 간 자원공유는 시스템 처리 비용이 적고 프로그램 응답 시간도 단축됨
    - 단점 : 스택 영역을 다른 스레드와 함께 사용하므로 공유 자원에 대한 동기화가 필수이며, 스레드에 문제가 발생하면 프로세스 내 다른 스레드에 영향을 미칠 수 있음

### 2.6. 콘텍스트 스위칭 (⭐️⭐️⭐️)

<aside>
💡 인터럽트(interrupt) : 입출력 관련 이벤트 및 예외 상황 발생 시 대응할 수 있게 CPU에 처리를 요청 (: 방해하다, 중단시키다)

</aside>

- **콘텍스트(context)** : CPU가 처리하는 프로세스의 정보
- **콘텍스트 스위칭(context switching)** : 멀티 프로세스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것
- 프로그램 카운터(PC, Program Counter) : 프로세스가 이어서 처리해야 하는 명령어의 주소 값
- 스택 포인터(stack pointer) : 스택 영역에서 데이터가 채워진 가장 높은 주소 값
    → PCB에 프로그램 카운터와 스택 포인터 값이 저장되어 있기 때문에 CPU에서 처리 중인 프로세스가 중간에 변경되어도 이전에 실행하던 코드를 이어서 실행 가능
    → 이어서 실행할 명령어의 주소 값 및 스택에 채워진 데이터 위치를 알고 있으므로 콘텍스트 스위칭이 원활히 이루어짐 
    

### 2.7. 프로세스 동기화(Process synchronization) (⭐️⭐️⭐️)

- **경쟁 상태(race condition)** : 여러 프로세스/스레드에서 하나의 공유 자원에 동시에 접근해 경쟁하는 상태
    → 접근 순서에 따라 결과 값이 달라질 수 있음
- **임계 영역(critical section)** : 공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역

> 임계 영역에서 경쟁 상태가 발생하는 것을 방지하려면 여러 프로세스가 공유 자원에 접근해도 데이터의 일관성이 유지되도록 **프로세스 동기화**를 해야함
> 
- 임계 영역 - 동시 접근 방지 조건 3가지
    - 상호배제 기법(mutual exclusive) : 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근 불가 (뮤텍스, 세마포어)
    - 진행(progress) : 임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행
    - 한정된 대기(bounded waiting) : 임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않음

<aside>
💡 뮤텍스(mutex) : lock을 가진 프로세스만이 공유 자원에 접근
**세마포어(semaphore)** : 공유 자원에 접근 가능한 프로세스의 수를 정해 접근을 제어

</aside>

### 2.8. 교착 상태(deadlock) (⭐️⭐️⭐️)

- **교착 상태** : 2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태
- 교착 상태가 발생하는 **4가지 필요충분조건**
    - 상호배제(mutual exclusion) : 하나의 공유 자원에 하나의 프로세스만 접근 가능
    - 점유와 대기(hold and wait) : 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기
    - 비선점(non-preemption) : 다른 프로세스에 할당된 자원 뺏기 불가
    - 환형 대기(circular wait) : 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구
- 교착 상태를 막으려면 필요충분조건 중 한 가지를 제거해야 함
    - 상호배제 부정 : 여러 프로세스가 동시에 하나의 공유 자원을 사용할 수 있게 함
    - 점유와 대기 부정 : 프로세스가 실행되기 전에 필요한 모든 자원을 할당함으로써 프로세스 대기를 없애거나, 프로세스가 자원을 점유하지 않은 상태에서만 자원을 요구하게 함
    - 비선점 부정 : 자원을 점유한 프로세스가 다른 자원을 요구할 때 점유한 자원을 반납하게 함
    - 환형 대기 부정 : 자원을 선형 순서로 정렬해 고유번호 할당하고, 각 프로세스에서 요구 가능한 번호의 방향을 정해서 한 반향으로만 자원을 요구하게 함
    

### 2.9. 스레드 안전

- 스레드 안전(thread safe) : 하나의 변수, 함수, 객체에 스레드 여러개가 동시에 접근해도 문제가 없음을 의미
- 스레드 안전을 위한 조건
    - 상호배제(mutual exclusion) : 공유 자원에 접근해야 할 때 뮤텍스 또는 세마포어와 가은 상호배제 기법을 사용해 접근을 통제
    - 원자 연산(atomic operation) : 공유 자원에 접근 할 때 원자 연산을 이용하거나 원자적으로 정의된 연산을 이용 → 연산 도중 다른 스레드가 접근 불가
    - 재진입성(reentrancy) : 특정 함수를 하나의 스레드에서 실행 중일 때 다른 스레드가 해당 함수를 실행해도 각 스레드에 올바른 결과가 나올 수 있게함
    - 스레드 지역 저장소(thread local storage) : 각 스레드에서만 접근할 수 있는 저장소를 사용해서 공유되는 자원을 줄임

### 2.10. IPC(Inter Process Communication)

- IPC : 프로세스 간 자원을 공유하는 방식
    - 공유 메모리(shared memory) : 프로세스 간 공유 가능한 메모리를 구성해 자원을 공유
        → 여러 프로세스에서 접근 가능하므로 동기화 문제 발생
    - 소켓(socket) : 네트워크 소켓을 이용하는 프로세스 간 통신
        → 외부 시스템과도 이용 가능, client와 server 구조로 자원을 주고받음
    - 세마포어(semaphore) : 접근하는 프로세스를 제어해 공유 자원을 관리
    - 파이프(pipe) : FIFO형태의 메모리인 파이프를 이용해 프로세스 간 자원 공유
        → 단방향 통신만 지원하므로 읽기 또는 쓰기 중 하나만 가능
    - 메시지 큐(message queue) : FIFO형태의 큐 자료구조를 사용해 프로세스 간 메세지를 주고 받음

### 2.11. 좀비 프로세스와 고아 프로세스

- 좀비 프로세스(zombie process)
	- 자식 프로세스가 종료됐지만 부모 프로세스가 자식의 종료 상태를 회수하지 않았을 경우, 남겨진 자식 프로세스를 좀비 프로세스라고 함
    - 자원 회수에 실패하면 좀비 프로세스가 생기고, 좀비 프로세스가 쌓이면 자원이 낭비됨
- 고아 프로세스(orphan process)
	- 부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우, 자식프로세스를 고아 프로세스라고 함


# 1.4. 메모리 관리 전략

### 1.4.1. 논리 메모리와 물리 메모리

- 논리 메모리 영역(logical memory address space) / 가상 메모리 영역(virtual memory address space)
	- 프로세스가 보는 메모리 영역
- 물리 메모리 영역(physical memory address space)
	- 실제로 사용되는 메모리 영역(RAM)
- 논리 주소(logical address) / 가상 주소(virtual address)
	- CPU가 프로세스를 실행하며 보는 주소 값
- 물리 주소(physical address)
	- 실제 메모리에서 사용되는 주소

- **메모리 관리 장치(MMU, Memory Management Unit)**
    - 논리 주소를 물리주소로 변환해주는 하드웨어 장치
        → 프로세스 실행시 사용하는 주소값과 실제 주소값은 다르므로, 논리 주소를 물리 주소로 변환해야 함
    - CPU에 위치하며, 메모리에 접근하기 전에 MMU를 거쳐 물리 주소를 얻음
    - 메모리 영역 접근을 제한하여 메모리를 보호하는 역할을 함
    ![LT4oQmZ.png](https://i.imgur.com/LT4oQmZ.png)
        ▲ MMU 작동 방식

### 1.4.2. 연속 메모리 할당

- **연속 메모리 할당(contiguous allocation)** : 멀티 프로세스 환경에서 여러 프로세스를 메모리에 연속적으로 로드하는 방법
- 연속 메모리 할당 2가지 방식
    1. `고정 분할 방식` : 메모리 영역을 분할한 뒤 각 영역에 프로세스를 할당
        - 분할된 영역의 크기는 서로 다를 수 있으며 분할된 크기는 고정됨
        - 단점 : 메모리에 올릴 수 있는 프로세스의 수와 크기가 제한되며, 단편화 문제가 발생할 수 있음
        
        <aside>
        💡 단편화 : RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태
        </aside>
        <aside>
        → 내부 단편화 : 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 
             메모리 공간이 낭비되는 상황 (다른 프로세스가 사용할 수 없는 상태)
        </aside>
        <aside>
        → 외부 단편화 : 남아있는 메모리의 크기가 실행하고자 하는 프로세스보다 크지만, 연속적이지
             않은 공간에 존재하여 실행하지 못하는 현상을 의미 (중간에 생긴 사용하지 않는 메모리가
             많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당이 불가한 상황)
        
        </aside>
        
        <aside>
        💡 외부 단편화 문제 해결 방법 : 메모리 압축 (=메모리 집약)
        </aside>
        <aside>
        → 사용 중인 메모리 공간을 재배치해서 흩어져 있는 가용 메모리 공간을 하나로 합침
        
        </aside>

    2. `가변 분할 방식` : 할당할 프로세스의 크기에 따라 메모리 공간을 분할하는 방식
        - 메모리 할당 알고리즘을 통해 가용 메모리 공간에서 프로세스가 로드될 수 있는 메모리 공간을 찾음
        - 메모리 할당 알고리즘 : 최초 적합, 최적 적합, 최악 적합
            - 최초 적합(first-fit) : 가용 메모리 공간에서 프로세스 크기만큼 비어있는 메모리 공간을 찾아 차례대로 프로세스를 로드하는 방식
            - 최적 적합(best-fit) : 할당하려는 프로세스 크기 이상인 가용 메모리 공간에서 가장 작은 공간에 프로세스를 할당하는 방식 (가용 메모리 공간을 모두 탐색해야함)
            - 최악 적합(worst-fit) : 할당하려는 프로세스 크기보다 큰 가용 메모리 공간에서 가장 큰 공간에 프로세스를 할당하는 방식 (가용 메모리 공간을 모두 탐색해야함)
    

### 1.4.3. 비연속 메모리 할당 (⭐️⭐️⭐️)

- **비연속 메모리 할당** : 프로세스의 메모리 영역을 나눠서 메모리 공간에 저장하는 방법
- 비연속 메모리 할당 2가지 방식 : 페이징
    1. `페이징(paging)` : 프로세스의 논리 및 물리 메모리 영역을 일정한 크기의 페이지와 프레임으로 나눔
        - 페이지와 프레임 크기는 동일
        - 페이지와 프레임에 각각 번호를 할당해 프로세스의 페이지와 메모리의 프레임을 매핑
        - 페이지 테이블(page table)
            - 페이지 및 프레임 매핑 시 페이지 테이블 사용
            - 프로세스의 페이지 정보와 페이지에 매핑하는 프레임의 주소 값을 저장
            - 페이지 테이블은 각 프로세스의 PCB에 저장됨
            - 페이지 테이블을 저장하기 위한 메모리 공간 추가로 필요
        - 페이지를 물리 메모리에 연속으로 할당할 필요가 없으므로 **외부 단편화 문제 해결 가능**
        - 프로세스 크기가 페이지 수로 나누어 떨어지지 않을 수 있고, 프로세스의 마지막 페이지가 페이지 크기보다 작을 수 있으므로 내부 단편화 문제 발생 가능

    2. `세그먼테이션(segmentation)` : 프로세스의 메모리 영역을 논리적 단위인 세그먼트로 분할해 연속되지 않는 물리 메모리 공간에 할당될 수 있도록 하는 메모리 관리 기법
        - 논리적 단위 : 파일 내 함수 단위나 프로세스의 스택, 힙과 같은 영역을 의미
        - 세그먼테이션 테이블을 사용해 세그먼트의 논리 주소를 물리 주소로 매핑
        - 세그먼테이션 테이블 : 세그먼트 번호를 인덱스로 사용하며, 세그먼트별 시작 주소인 base와 세그먼트 길이인 limit을 저장

| 구분  | 내용                                                                                                                                                                                               |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 장점  | - 프로세스의 메모리 영역을 논리적 단위로 나눠 저장하므로 단위별로 데이터를 보호하기 쉬움                                                                                                                                               |
| 단점  | - 세그먼트의 크기가 균등하지 않아서 프로세스의 할당/해제를 반복하는 과정에서 외부 단편화 <br>  문제 발생 가능 <br>- 메모리에 로드된 스택 세그먼트 영역에서 오버플로가 발생하면 다른 프로세스와 메모리 영역이 <br>  중복될 수 있음 <br>  → 다른 프로세스의 세그먼트나 스택 오버플로가 발생한 세그먼트를 디스크로 스왑 아웃해야함 |

>		**페이징 기법 3가지**
            1. 계층적 페이징(hierarchical paging)
               - 페이지 테이블을 다시 페이지로 나눠 페이지 테이블 자체를 페이징하는 방식
               - 멀티 레벨 페이징(multi-level paging)이라고도 함
            2. 해시 페이지 테이블(hashed page table)
               - 해시 테이블의 각 항목에 저장된 연결 리스트에 페이지 번호를 해싱한 뒤, 첫 번째 요소와 가상페이지 번호를 비교하는 방식
            3. 역 페이지 테이블(inverted page table)
               - 프레임을 이용해 페이지를 찾는 방식 (기존 방식과 반대)


- Paging과 Segment의 차이점
	- paging은 일정한 크기의 단위로 나누어 할당하는데 반해, segmentation은 code, data, heap, stack 등의 기능(의미)단위로 물리 메모리에 할당하는 기법이다.
