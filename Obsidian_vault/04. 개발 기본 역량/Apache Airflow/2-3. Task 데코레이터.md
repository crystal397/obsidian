- # 데코레이터란?
	- 데코레이터(Decorator): 장식하다, 꾸미다
	- 원래의 함수를 감싸서(Wrapping) 바깥에 추가 기능을 덧붙이는 방법
- # 함수를 감싼다?
	- 함수의 인자로 함수를 전달하는 것이 가능
	- 파이썬은 함수 안에 함수를 선언하는 것이 가능
	- 함수 자체를 리턴하는 것이 가능
		![](https://i.imgur.com/7Jiur1s.png)
- # 데코레이터의 필요성
	- 기존에 사용하던 함수 some_func()가 있다고 가정
		```
		def_ _some_func__():
			print('작업을 시작합니다')
		```
	- 이 함수를 사용할 때에는 아래와 같이 단순히 호출을 하여 사용
		`some_func()`
	- 그런데 some_func() 사용 전후로 로그를 저장해야 한다면?
		- 해결방안 1) some_func() 함수를 수정하여 시작 지점과 끝에 로그를 추가
			```
			def_ _some_func__():
				print('작업을 시작 전입니다')
				print('작업을 시작합니다')
				print('작업을 마칩합니다')
			```
		- 해결방안 2) 함수를 사용하는 로직에서 전/후에 로그를 추가
			```
			print('작업을 시작 전입니다')
			some_func()
			print('작업을 마칩합니다')
			```
		- 해결방안 3) 데코레이터 사용
- # 데코레이터 사용하기
	- ## 데코레이터 정의
		```
		def outer_func(target_func):
			def inner_func():
				print('target 함수 실행 전 입니다')
				target_func()
				print('target 함수 실행 후 입니다')
			retur inner_func
		```
	- ## some_func 함수 변경
		( 함수 정의 위에 @기호에 데코레이터 정의를 붙임)
		```
		@outer_func
			def some_func():
				print('작업을 시작합니다')
		```
	- ## some_func 호출
		`some_func()`
	- 만약 단순 로그 추가가 아니라 수정해야 하는 로직이 복잡하고, 공통적으로 사용해야 할 함수가 많다면
		- 해결방안 1) 함수 하나씩 수정
		- 해결방안 2) 공통 수정해야 하는 로직을 데코레이터로 정의하고 기존 함수 정의에 데코레이터를 적용
			![520](https://i.imgur.com/PckcG9m.png)
	- ## Python Operator의 대체, task 데코레이터
		- Airflow에도 데코레이터를 이용해 python Operator를 쉽게 만들수 있음
		- 실행 하고자 하는 python 함수 정의 후 @task 데코레이터만 붙여주면됨
			![250](https://i.imgur.com/jsQgO4F.png)
		- dags_python_task_decorator
		    ```jsx
		    from airflow import DAG
		    import pendulum
		    from airflow.decorators import task
		    
		    with DAG(
		        dag_id="dags_python_task_decorator",
		        schedule="0 2 * * 1",
		        start_date=pendulum.datetime(2024, 6, 14, tz="Asia/Seoul"),
		        catchup=False,
		    ) as dag:
		        
		        @task(task_id="python_task_1")
		        def print_context(some_input):
		            print(some_input)
		    
		        python_task_1 = print_context('task_decorator 실행')
		    ```
- # 파라미터 전달
    - ## Python Operator 의 파라미터 전달
	    - 파이썬 오퍼레이터의 스펙 확인
	        https://airflow.apache.org/docs/apache-airflow/stable/_api/airflow/operators/python/index.html
	    - 파라미터를 넘겨주기 위해 op_kwargs 또는 op_args 파라미터 사용 가능
	        - kwargs, args 란??
    - ## 파이썬의 args와 kwargs
	    - 파이썬 함수 작성시 일반적으로 아래와 같이 작성
	        ```jsx
	        def regist(name, sex):
	        	print(name)
	        	print(sex)
	        ```
	    - Optional 성격의 파라미터가 올 수 있는 경우에는? (주소, 전화번호 등)
	        - 해결방안 1) 올 수 있는 파라미터는 모두 정의한다.
	            ```jsx
	            def regist(name, sex, addresss, p_num):
	            	print(name)
	            	print(sex)
	            	print(address)
	            	print(p_num)
	            ```
	        - 해결방안 2) args 또는 kwargs를 이용한다.
    - ## args 이용하기
	    - args를 이용하면 regist 함수를 호출하는 구문에서 던지는 파라미터를 모두 받을수 있다
		    ![](https://i.imgur.com/05zjl46.png)
	    - args로 들어온 값은 튜플로 저장
	    - args에서 값을 꺼낼 때는 인덱스를 이용 (ex. args[0]. args[1])
	    - args라는 이름 외 다른 이름으로 받아도 된다 (ex. some_func(*kk):)
	    - args는 튜플이므로 몇 번째 인덱스가 어떤 파라미터에 대한 값인지 불분명하다는 단점 존재
	- ## kwargs 이용하기
		- kwargs를 이용하면 dictionary 형태로 파라미터를 받을 수 있음
		    ![](https://i.imgur.com/7WKnhhD.png)
		- 호출 하는 로직(오른쪽) 에서 파라미터명=값 형태로 호출하면 됨
		- 함수 정의 부분에서는 딕셔너리로 값을 받음
		- args와 마찬가지로 꼭 krargs 라는 이름을 사용할 필요 없으며 **aa 와 같이 정의해도 무방함
	- ## args와 kwargs 함께 이용하기
		- args와 kwargs는 함께 사용할 수 있으나 args가 먼저, kwargs가 뒤에 정의되어야 함
		   ![500](https://i.imgur.com/wgv13kZ.png)
		- 호출하는 로직(오른쪽) 에서는 파라미터명=값 형태로 호출하면됨
		- 함수 정의 부분에서는 딕셔너리로 값을 받음
		- args와 krargs 라는 이름을 사용할 필요 없음
	- ## Python 오퍼레이터에서 파라미터 전달하기
		- Python Operator의 op_args와 op_kwargs 사용하여 파라미터 전달
		- ==op_args는 리스트로 작성하며 args로 캡쳐됨
		- ==op_kwargs는 딕셔너리로 작성하며 kwargs로 캡쳐
		    ![](https://i.imgur.com/df0q8dq.png)
		```jsx
		from airflow import DAG
		import pendulum
		from airflow.operators.python import PythonOperator
		from common.common_func import regist2
		with DAG(
		    dag_id="dags_python_with_op_kwargs",
		    schedule="30 6 * * *",
		    start_date=pendulum.datetime(2024, 6, 14, tz="Asia/Seoul"),
		    catchup=False
		) as dag:
		    
		    regist2_t1 = PythonOperator(
		        task_id='regist2_t1',
		        python_callable=regist2,
		        op_args=['hjkim','man','kr','seoul'],
		        op_kwargs={'email':'hjkim_sun@naver.com','phone':'010'}
		    )
		
		    regist2_t1
		```
	- ## @task 데코레이터에서 파라미터 전달하기
		- task 데코레이터 사용시 파라미터는 직접 전달 가능
		- dags_python_decorator_with_param
	    ```jsx
	    from airflow import DAG
	    import pendulum
	    from airflow.decorators import task
	    
	    with DAG(
	        dag_id="dags_python_decorator_with_param",
	        schedule="0 2 * * 1",
	        start_date=pendulum.datetime(2024, 6, 14, tz="Asia/Seoul"),
	        catchup=False,
	    ) as dag:
	    
	        @task(task_id="python_task_1")
	        def regist3(name, sex, *args, **kwargs):
	            print(f'이름: {name}')
	            print(f'성별: {sex}')
	            print(f'기타옵션들: {args}')
	            email = kwargs['email'] or 'empty'
	            phone = kwargs['phone'] or 'empty'
	            print(f'email: {email}')
	            print(f'phone: {phone}')
	            from pprint import pprint
	            pprint(kwargs)
	    
	        python_task_1 = regist3('hjkim', 'man', 'seoul', email='hjkim_sun@naver.com', phone='010')
	    ```

